)
for (i in 1:n) Hess.FullNumer.unScale[, , i] = G[i, ] %*% t(G[i, ])
loop = 0
iter.diff = Inf
old.Theta = init.theta
while (loop < 15 & iter.diff > 1e-04) {
loop = loop + 1
GH = cosso::gradient.Hessian.Theta(old.Theta, c.hat, G, G,
lambda0, lambda_theta, time, status, Risk, Hess.FullNumer.unScale)
if(min(eigen(GH$H)$value) < 0)
GH$H = GH$H + max(1e-07, 1.5 * abs(min(eigen(GH$H)$value))) * diag(length(init.theta))
dvec = -(GH$G - GH$H %*% old.Theta)
Amat = t(rbind(diag(p), rep(-1, p)))
bvec = c(rep(0, p), -lambda_theta)
new.Theta = cosso::My_solve.QP(GH$H, dvec, Amat, bvec)
new.Theta[new.Theta < 1e-07] = 0
iter.diff = mean(abs(new.Theta - old.Theta))
old.Theta = new.Theta
}
return(new.Theta)
}
fit3
make_kernel = function (x, y, type)
{
n1 <- nrow(x)
n2 <- nrow(y)
d <- ncol(x)
K <- array(0, c(n1, n2, d))
for (j in 1:d) {
K[, , j] <- kernelMatrix(x, y, type)
}
return(K)
}
spline_kernel = function(x, y)
{
x = as.matrix(x)
y = as.matrix(y)
K1x = (x - 1 / 2)
K1y = (y - 1 / 2)
K2x = (K1x^2 - 1 / 12) / 2
K2y = (K1y^2 - 1 / 12) / 2
ax = x %x% matrix(1, 1, nrow(y))
ay = y %x% matrix(1, 1, nrow(x))
b = abs(ax - t(ay))
K1 = K1x %x% t(K1y)
K2 = K2x %x% t(K2y) - ((b - 1 / 2)^4 - (b - 1 / 2)^2 / 2 + 7 / 240) / 24
list(K1 = K1, K2 = K2)
}
kernelMatrix = function(x, y, type, kparam = 1.0) {
x = as.matrix(x)
y = as.matrix(y)
p = ncol(x)
if (ncol(x) == 0) {
x = matrix(0, nrow = nrow(x), ncol = 1)
}
if (ncol(y) == 0) {
y = matrix(0, nrow = nrow(y), ncol = 1)
}
if (type == "poly") {
K = (x %*% t(y) + 1.0)^kparam
}
if(type == "gaussian" | type == "gaussian2") {
normx = rowSums(x^2)
normy = rowSums(y^2)
temp = x %*% t(y)
temp = (-2.0 * temp) + outer(normx, rep(1.0, nrow(y)), "*") + outer(rep(1.0, nrow(x)), normy, "*")
K = exp(-temp * kparam)
# obj = kernelMatrix(rbfdot(sigma = kparam), x, y)
}
if (type == "spline") {
K = 0
for (d in 1:p) {
K_temp = spline_kernel(x[, d, drop = FALSE], y[, d, drop = FALSE])
K = K + K_temp$K1 + K_temp$K2
}
}
if (type == "linear") {
K = tcrossprod(x, y)
}
return(K)
}
make_anovaKernel = function(x, y, type, kparam)
{
x = as.matrix(x)
y = as.matrix(y)
dimx = ncol(x)
# calculate anova kernels for main effects
# if (type == "spline") {
#   # assign the number of anova kernels
#   numK = 2 * dimx
#   # list of kernel matrices
#   anova_kernel = vector(mode = "list", numK)
#   # list of kernel coordinate indices
#   kernelCoord = vector(mode = "list", numK)
#   index = 0
#
#   for (d in 1:dimx) {
#     index = index + 1
#     A = x[, d, drop = FALSE]
#     B = y[, d, drop = FALSE]
#     K_temp = spline_kernel(A, B)
#     anova_kernel[[index]] = K_temp$K1
#     kernelCoord[[index]] = paste("x", d, " linear", sep="")
#     index = index + 1
#     anova_kernel[[index]] = K_temp$K2
#     kernelCoord[[index]] = paste("x", d, " smooth", sep="")
#   }
#
# } else if (type == 'spline2') {
#   numK = (2 * dimx) + (2 * dimx * (2 * dimx - 1) / 2 - dimx)
#   anova_kernel = vector(mode = "list", numK)
#   kernelCoord = vector(mode = "list", numK)
#   index = 0
#   # main effects
#   for (d in 1:dimx) {
#     index = index + 1
#     A = x[, d, drop = FALSE]
#     B = y[, d, drop = FALSE]
#     K_temp = spline_kernel(A, B)
#     anova_kernel[[index]] = K_temp$K1
#     kernelCoord[[index]] = paste("x", d, " linear", sep = "")
#     index = index + 1
#     anova_kernel[[index]] = K_temp$K2
#     kernelCoord[[index]] = paste("x", d, " smooth", sep = "")
#   }
#   # two-way interactions
#   for (i in 1:(dimx - 1)) {
#     for (j in (i + 1):dimx) {
#       index = index + 1
#       A_linear = as.matrix(anova_kernel[[2 * i - 1]])
#       A_smooth = as.matrix(anova_kernel[[2 * i]])
#       B_linear = as.matrix(anova_kernel[[2 * j - 1]])
#       B_smooth = as.matrix(anova_kernel[[2 * j]])
#       anova_kernel[[index]] = A_linear * B_linear
#       kernelCoord[[index]] = paste("x", i, " linear,", " x", j, " linear", sep = "")
#       index = index + 1
#       anova_kernel[[index]] = A_linear * B_smooth
#       kernelCoord[[index]] = paste("x", i, " linear,", " x", j, " smooth", sep = "")
#       index = index + 1
#       anova_kernel[[index]] = A_smooth * B_linear
#       kernelCoord[[index]] = paste("x", i, " smooth,", " x", j, " linear", sep = "")
#       index = index + 1
#       anova_kernel[[index]] = A_smooth * B_smooth
#       kernelCoord[[index]] = paste("x", i, " smooth,", " x", j, " smooth", sep = "")
#     }
#   }
# } else
if (type == "spline-t") {
numK = dimx
anova_kernel = vector(mode = "list", numK)
kernelCoord = vector(mode = "list", numK)
index = 0
for (d in 1:dimx) {
index = index + 1
A = x[, d, drop = FALSE]
B = y[, d, drop = FALSE]
K_temp = spline_kernel(A, B)
anova_kernel[[index]] = (K_temp$K1 + K_temp$K2)
kernelCoord[[index]] = paste("x", d, sep = "")
}
} else if (type == 'spline-t2') {
numK = dimx + dimx * (dimx - 1) / 2
anova_kernel = vector(mode = "list", numK)
kernelCoord = vector(mode = "list", numK)
index = 0
for (d in 1:dimx) {
index = index + 1
A = x[, d, drop = FALSE]
B = y[, d, drop = FALSE]
K_temp = spline_kernel(A, B)
anova_kernel[[index]] = (K_temp$K1 + K_temp$K2)
kernelCoord[[index]] = paste("x", d, sep = "")
}
for (i in 1:(dimx - 1)) {
for (j in (i + 1):dimx) {
index = index + 1
A = anova_kernel[[i]]
B = anova_kernel[[j]]
anova_kernel[[index]] = A * B
kernelCoord[[index]] = paste("x", i, " x", j, sep = "")
}
}
} else if (type == "gaussian2") {
numK = dimx + dimx * (dimx - 1) / 2
anova_kernel = vector(mode = "list", numK)
kernelCoord = vector(mode = "list", numK)
index = 0
for (d in 1:dimx) {
index = index + 1
A = x[, d, drop = FALSE]
B = y[, d, drop = FALSE]
anova_kernel[[index]] = kernelMatrix(A, B, type, kparam)
kernelCoord[[index]] = paste("x", d, sep = "")
}
for (i in 1:(dimx - 1)) {
for (j in (i + 1):dimx) {
index = index + 1
A = anova_kernel[[i]]
B = anova_kernel[[j]]
anova_kernel[[index]] = A * B
kernelCoord[[index]] = paste("x", i, " x", j, sep = "")
}
}
} else {
numK = dimx
anova_kernel = vector(mode = "list", numK)
kernelCoord = vector(mode = "list", numK)
for (d in 1:dimx) {
A = x[, d, drop = FALSE]
B = y[, d, drop = FALSE]
anova_kernel[[d]] = kernelMatrix(A, B, type, kparam)
kernelCoord[[d]] = paste("x", d, sep = "")
}
}
return(list(x = x, K = anova_kernel, coord = kernelCoord, numK = numK, kernel = type, kparam = kparam))
}
# is used to combine anova kernel matrices with weights determined by theta values. The default theta vector is the vector of ones.
combine_kernel = function(anova_kernel, theta = rep(1, anova_kernel$numK))
{
K = 0
for (d in 1:anova_kernel$numK) {
K = (K + theta[d] * anova_kernel$K[[d]])
}
return(K)
}
rescale = function (x)
{
if (length(unique(x)) > 6)
return((x - min(x))/(max(x) - min(x)))
else return(x)
}
wsGram = function (Gramat, mscale)
{
n1 <- dim(Gramat)[1]
n2 <- dim(Gramat)[2]
d <- dim(Gramat)[3]
KK <- matrix(0, n1, n2)
for (j in 1:d) KK = KK + mscale[j] * Gramat[, , j]
return(KK)
}
rescale_theta = function (x)
{
d = length(x)
if(sum(x == 0) == d) x = rep(1e-10, d)
return(x)
}
cvsplitID = function (n, folds)
{
fsize <- floor(n/folds)
splits <- fsize * rep(1, folds)
nextra <- n - folds * fsize
if (nextra > 0) {
splits[1:nextra] <- splits[1:nextra] + 1
}
randid <- sample(1:n, n)
IDmat <- matrix(NA, ncol = folds, nrow = ceiling(n/folds))
IDmat[, 1] <- randid[1:splits[1]]
for (i in 2:folds) {
tempid <- randid[(cumsum(splits)[i - 1] + 1):(cumsum(splits)[i])]
length(tempid) <- ceiling(n/folds)
IDmat[, i] <- tempid
}
return(IDmat)
}
time = unlist(y[, "time"])
time = unlist(te_y[, "time"])
status = unlist(te_y[, "status"])
# library(survival)
n = nrow(x)
d = length(wt)
par(mfrow = c(2,2))
# time = unlist(te_y[, "time"])
# status = unlist(te_y[, "status"])
# type = "spline"
# algo = "CD"
# family = 'Cox'
# gamma = 0.95,
# lambda0 = exp(seq(log(2^{-22}), log(2^{2}), length.out = 20))
wt = rep(1, d)
# library(survival)
n = nrow(x)
d = length(wt)
x = tr_x
time = unlist(tr_y[, "time"])
status = unlist(tr_y[, "status"])
# library(survival)
n = nrow(x)
d = length(wt)
par(mfrow = c(2,2))
# solve theta
getc_cvfit  = cv.getc(x, time, status, rep(1, d)/wt^2, lambda0, one.std, type, kparam, algo)
type = "spline"
algo = "CD"
family = 'Cox'
lambda0 = exp(seq(log(2^{-22}), log(2^{2}), length.out = 20))
wt = rep(1, d)
# solve theta
getc_cvfit  = cv.getc(x, time, status, rep(1, d)/wt^2, lambda0, one.std, type, kparam, algo)
# x = tr_x
# time = unlist(tr_y[, "time"])
# status = unlist(tr_y[, "status"])
# type = "spline"
# algo = "CD"
# family = 'Cox'
# gamma = 0.95,
kparam=1
# solve theta
getc_cvfit  = cv.getc(x, time, status, rep(1, d)/wt^2, lambda0, one.std, type, kparam, algo)
getc_cvfit
time = unlist(tr_y[, 'time'])
status = unlist(tr_y[, 'status'])
mscale = rep(1, d)/wt^2
nfolds = 5
cand.lambda = lambda0
n <- length(time)
K = make_anovaKernel(x, x, type = type, kparam)
d = K$numK
R = array(NA, c(n, n, d))
for(j in 1:d){
R[, , j] = K$K[[j]]
}
Rtheta <- wsGram(R, mscale)
RS = RiskSet(time, status)
measure <- miss <- rep(0, length(cand.lambda))
for (k in 1:length(cand.lambda)){
if(algo == "CD"){
c.init = as.vector(glmnet(Rtheta, cbind(time = time, status = status), family = 'cox',
lambda = cand.lambda[k], alpha = 0, standardize = FALSE)$beta)
# zw = z * sqrt(w)
# Rw = Rtheta * w
# cw = c.init / sqrt(w)
# sw = sqrt(w)
fit = getc.cd(Rtheta, c.init, time, status, cand.lambda[k], RS)
# fit = .Call("Csspline", tr_Rtheta, Rtheta, n, n, RS, c.init, cand.lambda[k])
Lik = Partial_Lik(time, status, Rtheta, fit$c.new)
Rw = Rtheta * fit$w.new
XX = fit$zw.new - Rw %*% fit$cw.new - fit$b.new * fit$w.new
num = t(XX) %*% XX
den = (1 - sum(diag(Rtheta %*% ginv(Rtheta + diag(fit$w.new)/cand.lambda[k]))) / n)^2
measure[k] <- as.vector(num / den / n)
miss[k] = -Lik
}
if(algo == "QP"){
c.init = as.vector(glmnet(Rtheta, cbind(time = time, status = status), family = 'cox',
lambda = cand.lambda[k], alpha = 0, standardize = FALSE)$beta)
fit = getc.QP(R, Rtheta, c.init, time, status, mscale, cand.lambda[k], RS)
measure[k] <- cosso::PartialLik(time, status, RS, fit)
}
}
k
measure
miss
fit
c.init
as.vector(glmnet(Rtheta, cbind(time = time, status = status), family = 'cox',
lambda = cand.lambda[k], alpha = 0, standardize = FALSE)$beta)
c.init = as.vector(glmnet(Rtheta, cbind(time = time, status = status), family = 'cox',
lambda = cand.lambda[k], alpha = 0, standardize = FALSE)$beta)
getc.cd(Rtheta, c.init, time, status, cand.lambda[k], RS)
Rtheta
Rtheta %*% c.init
c.init = as.vector(glmnet(Rtheta, cbind(time = time, status = status), family = 'cox',
lambda = cand.lambda[k], alpha = 0, standardize = FALSE)$beta)
c.init
Rtheta %*% c.init
# zw = z * sqrt(w)
# Rw = Rtheta * w
# cw = c.init / sqrt(w)
# sw = sqrt(w)
fit = getc.cd(Rtheta, c.init, time, status, cand.lambda[k], RS)
# fit = .Call("Csspline", tr_Rtheta, Rtheta, n, n, RS, c.init, cand.lambda[k])
Lik = Partial_Lik(time, status, Rtheta, fit$c.new)
fit
# Rtheta = tr_Rtheta
# time = time[trainID]
# status = status[trainID]
# lambda0 = cand.lambda[k]
# Risk = tr_RS
getc.cd = function(Rtheta, c.init, time, status, lambda0, Risk)
{
n = ncol(Rtheta)
wz = calculate_wz_for_c(c.init, Rtheta, time, status, Risk)
w = wz$weight + 0.001
z = wz$z
b = 0
rm(wz)
zw = z * sqrt(w)
Rw = Rtheta * w
cw = c.init
cw.new = temp = c.init / sqrt(w)
sw = sqrt(w)
fit = .Call("c_step", zw, Rw, cw, sw, n, lambda0, PACKAGE = "cdcosso")
b.new = fit$b.new
c.new = fit$c.new
cw.new = fit$cw.new
return(list(Rw = Rw, zw.new = zw, w.new = w, sw.new = sw, b.new = b.new, c.new = c.new, cw.new = cw.new))
# for(i in 1:20){ # outer iteration
#   for(j in 1:n){
#     L = 2 * sum((zw - Rw[,-j] %*% cw[-j] - b * sw) * Rw[,j]) - n * lambda0 * c(Rw[j,-j] %*% cw[-j])
#     R = 2 * sum(Rw[,j]^2) + n * lambda0 * Rw[j,j]
#     temp[j] = L/R
#
#     loss = abs(cw - temp)
#     conv = max(loss) < 1e-6
#
#     if(conv) break
#     cw[j] <- cw.new[j] <- temp[j]
#   }
#   if(conv) break
# }
#
# c.new = cw.new * sw
# b.new = sum((zw - Rw %*% cw.new) * sw) / sum(sw)
#
# return(list(Rw = Rw, zw.new = zw, w.new = w, sw.new = sw, b.new = b.new, c.new = c.new, cw.new = cw.new))
}
c.init = as.vector(glmnet(Rtheta, cbind(time = time, status = status), family = 'cox',
lambda = cand.lambda[k], alpha = 0, standardize = FALSE)$beta)
getc.cd(Rtheta, c.init, time, status, cand.lambda[k], RS)
calculate_wz_for_c = function(c.init, R, time, status, RS){
n = length(time)
weight = z = rep(0, n)
for (k in 1:n) {
Sum.exp.eta.Grad = Sum.exp.eta.Hess = 0
id = which(RS[k,] > 0)
eta = as.numeric(R[k,] %*% c.init)
exp.eta = exp(eta)
for(r in id){
Sum.exp.eta = sum(exp(R[RS[,r],] %*% c.init))
Sum.exp.eta.Grad = Sum.exp.eta.Grad + exp.eta / Sum.exp.eta # {j in R_i} exp(R_j c)
Sum.exp.eta.Hess = Sum.exp.eta.Hess + ( exp.eta * Sum.exp.eta - exp.eta^2 ) / Sum.exp.eta^2
}
Grad.Term = status[k] - Sum.exp.eta.Grad
weight[k] = Sum.exp.eta.Hess
z[k] = eta + (Grad.Term + 0.1) / (weight[k] + 0.1)
}
return(list(z = z, weight = weight))
}
# Rtheta = tr_Rtheta
# time = time[trainID]
# status = status[trainID]
# lambda0 = cand.lambda[k]
# Risk = tr_RS
getc.cd = function(Rtheta, c.init, time, status, lambda0, Risk)
{
n = ncol(Rtheta)
wz = calculate_wz_for_c(c.init, Rtheta, time, status, Risk)
w = wz$weight
z = wz$z
b = 0
rm(wz)
zw = z * sqrt(w)
Rw = Rtheta * w
cw = c.init
cw.new = temp = c.init / sqrt(w)
sw = sqrt(w)
fit = .Call("c_step", zw, Rw, cw, sw, n, lambda0, PACKAGE = "cdcosso")
b.new = fit$b.new
c.new = fit$c.new
cw.new = fit$cw.new
return(list(Rw = Rw, zw.new = zw, w.new = w, sw.new = sw, b.new = b.new, c.new = c.new, cw.new = cw.new))
# for(i in 1:20){ # outer iteration
#   for(j in 1:n){
#     L = 2 * sum((zw - Rw[,-j] %*% cw[-j] - b * sw) * Rw[,j]) - n * lambda0 * c(Rw[j,-j] %*% cw[-j])
#     R = 2 * sum(Rw[,j]^2) + n * lambda0 * Rw[j,j]
#     temp[j] = L/R
#
#     loss = abs(cw - temp)
#     conv = max(loss) < 1e-6
#
#     if(conv) break
#     cw[j] <- cw.new[j] <- temp[j]
#   }
#   if(conv) break
# }
#
# c.new = cw.new * sw
# b.new = sum((zw - Rw %*% cw.new) * sw) / sum(sw)
#
# return(list(Rw = Rw, zw.new = zw, w.new = w, sw.new = sw, b.new = b.new, c.new = c.new, cw.new = cw.new))
}
c.init = as.vector(glmnet(Rtheta, cbind(time = time, status = status), family = 'cox',
lambda = cand.lambda[k], alpha = 0, standardize = FALSE)$beta)
c.init
getc.cd(Rtheta, c.init, time, status, cand.lambda[k], RS)
for (k in 1:length(cand.lambda)){
if(algo == "CD"){
c.init = as.vector(glmnet(Rtheta, cbind(time = time, status = status), family = 'cox',
lambda = cand.lambda[k], alpha = 0, standardize = FALSE)$beta)
# zw = z * sqrt(w)
# Rw = Rtheta * w
# cw = c.init / sqrt(w)
# sw = sqrt(w)
fit = getc.cd(Rtheta, c.init, time, status, cand.lambda[k], RS)
# fit = .Call("Csspline", tr_Rtheta, Rtheta, n, n, RS, c.init, cand.lambda[k])
Lik = Partial_Lik(time, status, Rtheta, fit$c.new)
Rw = Rtheta * fit$w.new
XX = fit$zw.new - Rw %*% fit$cw.new - fit$b.new * fit$w.new
num = t(XX) %*% XX
den = (1 - sum(diag(Rtheta %*% ginv(Rtheta + diag(fit$w.new)/cand.lambda[k]))) / n)^2
measure[k] <- as.vector(num / den / n)
miss[k] = -Lik
}
if(algo == "QP"){
c.init = as.vector(glmnet(Rtheta, cbind(time = time, status = status), family = 'cox',
lambda = cand.lambda[k], alpha = 0, standardize = FALSE)$beta)
fit = getc.QP(R, Rtheta, c.init, time, status, mscale, cand.lambda[k], RS)
measure[k] <- cosso::PartialLik(time, status, RS, fit)
}
}
measure
plot(measure)
