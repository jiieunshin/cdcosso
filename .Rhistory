if(response == "regression"){
f = f + rnorm(n, 0, 1)
out = list(x = data.frame(x), y = f)
}
if(response == "classification"){
prob = exp(f)/(exp(f) + 1)
y = rbinom(n, 1, prob)
# plot(prob)
# print(table(y))
out = list(x = data.frame(x), f = f, y = y)
}
if(response == "count"){
mu = exp(f/sqrt(2)/p)
y = rpois(n, mu)
out = list(x = data.frame(x), f = f, y = y)
}
if(response == 'survival'){
# f = 2 * f1(x[,1]) + 1 * f2(x[,2]) + 1 * f3(x[,3]) + 2 * f4(x[,4]) + 1 * f5(x[,5])
f = 2 * f1(x[,1]) + 5 * f2(x[,2]) + 4 * f3(x[,3]) + 3 * f4(x[,4]) + 3 * f5(x[,5]) # 잘 된 세팅. 근데 FP구분을 못함
# f = 2 * f1(x[,1]) + 1 * f2(x[,2]) + 5 * f3(x[,3]) + 4 * f4(x[,4]) + 1 * f5(x[,5]) #두 번째 세팅
surTime = rexp(n, (exp(f)))
cenTime = rexp(n, (exp(-f) * runif(1, 8, 10)))
y = cbind(time = apply(cbind(surTime, cenTime), 1, min), status = 1 * (surTime < cenTime))
# mean(y[,"status"])
out = list(x = data.frame(x), f = f, y = y)
}
return(out)
}
set.seed(i)
tr = data_generation(n, p, response = "survival")
tr_x = tr$x
tr_y = tr$y
te = data_generation(te_n, p, response = "survival")
te_x = te$x
te_y = te$y
RS = RiskSet(te_y[,"time"], te_y[,"status"])
t1 = system.time({
fit3 = try(cdcosso(tr_x, tr_y, family = 'Cox', gamma = 1, kernel = "spline", scale = T, algo = "QP"), silent = TRUE)
})[3]  # lambda2를 크게 할수록  sparse, gamma를 크게 할수록 sparse
fit3
fit10 = try(cdcosso(tr_x, tr_y, family = 'Cox', gamma = 0.95, kernel = "spline", scale = T, algo = "CD"), silent = TRUE)
fit10
#' and generates a predicted value for the test data.
#' This function uses the given test data to calculate predictions from the weights and biases generated by the model.
#'
#' @param n The number of observation of a example dataset.
#' @param p Dimension of a example dataset.
#' @param rho Correlation for first five significance variables.
#' @param response Type of response variable.
#'
#' @return a list containing the predicted value for the test data (f.new) and the transformed value of that predicted value (mu.new).
#' @export
data_generation = function(n, p, rho,
response = c("regression", "classification", "count", "survival", "interaction")){
f1 = function(t) t - 0.5
f2 = function(t) (2 * t - 1)^2 - 0.4
f3 = function(t) sin(2 * pi * t) / (2 - sin(pi * t))
f4 = function(t) 0.1*sin(2 * pi * t) + 0.2*cos(2 * pi * t) + 0.3*sin(2 * pi * t)^2 + 0.4*cos(2 * pi * t)^2 + 0.5*sin(2 * pi * t)^3 - 0.4
f5 = function(t) sin(pi * t^4) + t^4 - 0.4
f6 = function(t) 3 * (3 * t - 2)^2 - 3
# f7 = function(t) 4 * cos((3 * t - 1.5) * pi / 5)
# f1 = function(t) 3*t - 1.5
# f2 = function(t) pi * sin(pi * t) - 2
# f3 = function(t) (cos(2 * t) + sin(7 * t)) - 0.5
# f4 = function(t) 2 * t^5 - 0.2
# f5 = function(t) (sin(6 * t)^{3} + cos(6 * t)^{9})
if(missing(response))
type = "classification"
response = match.arg(response)
if(missing(n)) n = 200
if(missing(p)) p = 10
if(missing(rho)) rho = 0.5
if(p <= 5) stop("dimension size should be larger than 5.")
Sigma = matrix(rho, 5, 5)
diag(Sigma) = 1
x_sig = pnorm(rmvnorm(n, sigma = Sigma))
x_nois = matrix(pnorm(rnorm(n * (p-5))), n, p-5)
x = cbind(x_sig, x_nois)
# Set the outer margins
# par(oma = c(0, 0, 0, 0))
# Set the inner margin
# par(mar = c(4, 4, 3, 1))
# par(mfrow = c(1,5))
# plot(x[,1], f1(x[,1]), cex = .6, pch = 16, xlab = 'x1', ylab = 'f1')
# plot(x[,2], f2(x[,2]), cex = .6, pch = 16, xlab = 'x2', ylab = 'f2')
# plot(x[,3], f3(x[,3]), cex = .6, pch = 16, xlab = 'x3', ylab = 'f3')
# plot(x[,4], f4(x[,4]), cex = .6, pch = 16, xlab = 'x4', ylab = 'f4')
# plot(x[,5], f6(x[,5]), cex = .6, pch = 16, xlab = 'x5', ylab = 'f5')
# par(mfrow = c(1,1))
f = 5 * f1(x[,1]) + 3 * f2(x[,2]) + 4 * f3(x[,3]) + 6 * f4(x[,4]) + 4 * f5(x[,5])
# f = f1(x[,1]) + 2 * f2(x[,2]) + f3(x[,3]) + 2 * f4(x[,4]) +  f6(x[,5])
if(response == "regression"){
f = f + rnorm(n, 0, 1)
out = list(x = data.frame(x), y = f)
}
if(response == "classification"){
prob = exp(f)/(exp(f) + 1)
y = rbinom(n, 1, prob)
# plot(prob)
# print(table(y))
out = list(x = data.frame(x), f = f, y = y)
}
if(response == "count"){
mu = exp(f/sqrt(2)/p)
y = rpois(n, mu)
out = list(x = data.frame(x), f = f, y = y)
}
if(response == 'survival'){
# f = 2 * f1(x[,1]) + 1 * f2(x[,2]) + 1 * f3(x[,3]) + 2 * f4(x[,4]) + 1 * f5(x[,5])
f = 2 * f1(x[,1]) + 5 * f2(x[,2]) + 4 * f3(x[,3]) + 2 * f4(x[,4]) + 1 * f5(x[,5]) # 잘 된 세팅. 근데 FP구분을 못함
# f = 2 * f1(x[,1]) + 1 * f2(x[,2]) + 5 * f3(x[,3]) + 4 * f4(x[,4]) + 1 * f5(x[,5]) #두 번째 세팅
surTime = rexp(n, (exp(f)))
cenTime = rexp(n, (exp(-f) * runif(1, 8, 10)))
y = cbind(time = apply(cbind(surTime, cenTime), 1, min), status = 1 * (surTime < cenTime))
# mean(y[,"status"])
out = list(x = data.frame(x), f = f, y = y)
}
return(out)
}
set.seed(i)
tr = data_generation(n, p, response = "survival")
tr_x = tr$x
tr_y = tr$y
te = data_generation(te_n, p, response = "survival")
te_x = te$x
te_y = te$y
RS = RiskSet(te_y[,"time"], te_y[,"status"])
fit10 = try(cdcosso(tr_x, tr_y, family = 'Cox', gamma = 0.95, kernel = "spline", scale = T, algo = "CD"), silent = TRUE)
true_var = c(rep(1, p_sig), rep(0, p-p_sig))
en1_signal_varsel[i, ] = ifelse(fit10$theta_step$theta.new[1:p_sig] > 0, 1, 0)
en1_true = ifelse(fit10$theta_step$theta.new > 0, 1, 0)
en1_varsel[i] = sum(en1_true)
en1_tp[i] = metric(true_var, en1_true)$tp
metric(true_var, en1_true)
fit3 = try(cdcosso(tr_x, tr_y, family = 'Cox', gamma = 1, kernel = "spline", scale = T, algo = "QP"), silent = TRUE)
# x = tr_x
# time = unlist(tr_y[, "time"])
# status = unlist(tr_y[, "status"])
# type = "spline"
# algo = "CD"
# family = 'Cox'
# gamma = 0.95
# kparam=1
# lambda_theta = exp(seq(log(2^{-11}), log(2^{2}), length.out = 20))
# wt = rep(1, ncol(x))
cdcosso.cox = function (x, time, status, wt, lambda0, lambda_theta, gamma, type, kparam, scale, algo)
{
n = length(time)
p = length(wt)
# cat("fit COSSO  with n = ", n, "p =", p, "\n")
K = make_anovaKernel(x, x, type = type, kparam, scale)
d = K$numK
# cat("kernel:", type, "and d =", d, "\n")
par(mfrow = c(1,3))
# solve theta
getc_cvfit  = cv.getc(K, time, status, rep(1, d)/wt^2, lambda0, type, kparam, algo, show = TRUE)
theta_cvfit = cv.gettheta(getc_cvfit, x, time, status, wt, getc_cvfit$optlambda, lambda_theta, gamma, type, kparam, algo)
# solve (theta) - 2nd
theta.new = rescale_theta(theta_cvfit$theta.new)
print(theta.new)
getc_cvfit = cv.getc(K, time, status, theta.new/wt^2, lambda0, type, kparam, algo, show = TRUE)
par(mfrow = c(1,1))
out = list(data = list(x = x, time = time, status = status, RistSet = RiskSet(time, status), R = getc_cvfit$R, kernel = type, kparam = kparam),
tune = list(lambda0 = lambda0, lambda_theta = lambda_theta, gamma = gamma),
c_step = getc_cvfit,
theta_step = theta_cvfit,
family = "Cox",
algorithm = algo)
return(out)
}
fit3 = try(cdcosso(tr_x, tr_y, family = 'Cox', gamma = 1, kernel = "spline", scale = T, algo = "QP"), silent = TRUE)
fit3
fit10 = try(cdcosso(tr_x, tr_y, family = 'Cox', gamma = 0.95, kernel = "spline", scale = T, algo = "CD"), silent = TRUE)
#' and generates a predicted value for the test data.
#' This function uses the given test data to calculate predictions from the weights and biases generated by the model.
#'
#' @param n The number of observation of a example dataset.
#' @param p Dimension of a example dataset.
#' @param rho Correlation for first five significance variables.
#' @param response Type of response variable.
#'
#' @return a list containing the predicted value for the test data (f.new) and the transformed value of that predicted value (mu.new).
#' @export
data_generation = function(n, p, rho,
response = c("regression", "classification", "count", "survival", "interaction")){
f1 = function(t) t - 0.5
f2 = function(t) (2 * t - 1)^2 - 0.4
f3 = function(t) sin(2 * pi * t) / (2 - sin(pi * t))
f4 = function(t) 0.1*sin(2 * pi * t) + 0.2*cos(2 * pi * t) + 0.3*sin(2 * pi * t)^2 + 0.4*cos(2 * pi * t)^2 + 0.5*sin(2 * pi * t)^3 - 0.4
f5 = function(t) sin(pi * t^4) + t^4 - 0.4
f6 = function(t) 3 * (3 * t - 2)^2 - 3
# f7 = function(t) 4 * cos((3 * t - 1.5) * pi / 5)
# f1 = function(t) 3*t - 1.5
# f2 = function(t) pi * sin(pi * t) - 2
# f3 = function(t) (cos(2 * t) + sin(7 * t)) - 0.5
# f4 = function(t) 2 * t^5 - 0.2
# f5 = function(t) (sin(6 * t)^{3} + cos(6 * t)^{9})
if(missing(response))
type = "classification"
response = match.arg(response)
if(missing(n)) n = 200
if(missing(p)) p = 10
if(missing(rho)) rho = 0.5
if(p <= 5) stop("dimension size should be larger than 5.")
Sigma = matrix(rho, 5, 5)
diag(Sigma) = 1
x_sig = pnorm(rmvnorm(n, sigma = Sigma))
x_nois = matrix(pnorm(rnorm(n * (p-5))), n, p-5)
x = cbind(x_sig, x_nois)
# Set the outer margins
# par(oma = c(0, 0, 0, 0))
# Set the inner margin
# par(mar = c(4, 4, 3, 1))
# par(mfrow = c(1,5))
# plot(x[,1], f1(x[,1]), cex = .6, pch = 16, xlab = 'x1', ylab = 'f1')
# plot(x[,2], f2(x[,2]), cex = .6, pch = 16, xlab = 'x2', ylab = 'f2')
# plot(x[,3], f3(x[,3]), cex = .6, pch = 16, xlab = 'x3', ylab = 'f3')
# plot(x[,4], f4(x[,4]), cex = .6, pch = 16, xlab = 'x4', ylab = 'f4')
# plot(x[,5], f6(x[,5]), cex = .6, pch = 16, xlab = 'x5', ylab = 'f5')
# par(mfrow = c(1,1))
f = 5 * f1(x[,1]) + 3 * f2(x[,2]) + 4 * f3(x[,3]) + 6 * f4(x[,4]) + 4 * f5(x[,5])
# f = f1(x[,1]) + 2 * f2(x[,2]) + f3(x[,3]) + 2 * f4(x[,4]) +  f6(x[,5])
if(response == "regression"){
f = f + rnorm(n, 0, 1)
out = list(x = data.frame(x), y = f)
}
if(response == "classification"){
prob = exp(f)/(exp(f) + 1)
y = rbinom(n, 1, prob)
# plot(prob)
# print(table(y))
out = list(x = data.frame(x), f = f, y = y)
}
if(response == "count"){
mu = exp(f/sqrt(2)/p)
y = rpois(n, mu)
out = list(x = data.frame(x), f = f, y = y)
}
if(response == 'survival'){
# f = 2 * f1(x[,1]) + 1 * f2(x[,2]) + 1 * f3(x[,3]) + 2 * f4(x[,4]) + 1 * f5(x[,5])
f = 2 * f1(x[,1]) + 3 * f2(x[,2]) + 4 * f3(x[,3]) + 2 * f4(x[,4]) + 1 * f5(x[,5]) # 잘 된 세팅. 근데 FP구분을 못함
# f = 2 * f1(x[,1]) + 1 * f2(x[,2]) + 5 * f3(x[,3]) + 4 * f4(x[,4]) + 1 * f5(x[,5]) #두 번째 세팅
surTime = rexp(n, (exp(f)))
cenTime = rexp(n, (exp(-f) * runif(1, 8, 10)))
y = cbind(time = apply(cbind(surTime, cenTime), 1, min), status = 1 * (surTime < cenTime))
# mean(y[,"status"])
out = list(x = data.frame(x), f = f, y = y)
}
return(out)
}
set.seed(i)
tr = data_generation(n, p, response = "survival")
tr_x = tr$x
tr_y = tr$y
te = data_generation(te_n, p, response = "survival")
te_x = te$x
te_y = te$y
RS = RiskSet(te_y[,"time"], te_y[,"status"])
t1 = system.time({
fit3 = try(cdcosso(tr_x, tr_y, family = 'Cox', gamma = 1, kernel = "spline", scale = T, algo = "QP"), silent = TRUE)
})[3]  # lambda2를 크게 할수록  sparse, gamma를 크게 할수록 sparse
true_var = c(rep(1, p_sig), rep(0, p-p_sig))
en3_signal_varsel[i, ] = ifelse(fit3$theta_step$theta.new[1:p_sig] > 0, 1, 0)
fit3
fit10 = try(cdcosso(tr_x, tr_y, family = 'Cox', gamma = 0.95, kernel = "spline", scale = T, algo = "CD"), silent = TRUE)
fit10
fit3 = try(cdcosso(tr_x, tr_y, family = 'Cox', gamma = 1, kernel = "spline", scale = T, algo = "QP"), silent = TRUE)
#' and generates a predicted value for the test data.
#' This function uses the given test data to calculate predictions from the weights and biases generated by the model.
#'
#' @param n The number of observation of a example dataset.
#' @param p Dimension of a example dataset.
#' @param rho Correlation for first five significance variables.
#' @param response Type of response variable.
#'
#' @return a list containing the predicted value for the test data (f.new) and the transformed value of that predicted value (mu.new).
#' @export
data_generation = function(n, p, rho,
response = c("regression", "classification", "count", "survival", "interaction")){
f1 = function(t) t - 0.5
f2 = function(t) (2 * t - 1)^2 - 0.4
f3 = function(t) sin(2 * pi * t) / (2 - sin(pi * t))
f4 = function(t) 0.1*sin(2 * pi * t) + 0.2*cos(2 * pi * t) + 0.3*sin(2 * pi * t)^2 + 0.4*cos(2 * pi * t)^2 + 0.5*sin(2 * pi * t)^3 - 0.4
f5 = function(t) sin(pi * t^4) + t^4 - 0.4
f6 = function(t) 3 * (3 * t - 2)^2 - 3
# f7 = function(t) 4 * cos((3 * t - 1.5) * pi / 5)
# f1 = function(t) 3*t - 1.5
# f2 = function(t) pi * sin(pi * t) - 2
# f3 = function(t) (cos(2 * t) + sin(7 * t)) - 0.5
# f4 = function(t) 2 * t^5 - 0.2
# f5 = function(t) (sin(6 * t)^{3} + cos(6 * t)^{9})
if(missing(response))
type = "classification"
response = match.arg(response)
if(missing(n)) n = 200
if(missing(p)) p = 10
if(missing(rho)) rho = 0.5
if(p <= 5) stop("dimension size should be larger than 5.")
Sigma = matrix(rho, 5, 5)
diag(Sigma) = 1
x_sig = pnorm(rmvnorm(n, sigma = Sigma))
x_nois = matrix(pnorm(rnorm(n * (p-5))), n, p-5)
x = cbind(x_sig, x_nois)
# Set the outer margins
# par(oma = c(0, 0, 0, 0))
# Set the inner margin
# par(mar = c(4, 4, 3, 1))
# par(mfrow = c(1,5))
# plot(x[,1], f1(x[,1]), cex = .6, pch = 16, xlab = 'x1', ylab = 'f1')
# plot(x[,2], f2(x[,2]), cex = .6, pch = 16, xlab = 'x2', ylab = 'f2')
# plot(x[,3], f3(x[,3]), cex = .6, pch = 16, xlab = 'x3', ylab = 'f3')
# plot(x[,4], f4(x[,4]), cex = .6, pch = 16, xlab = 'x4', ylab = 'f4')
# plot(x[,5], f5(x[,5]), cex = .6, pch = 16, xlab = 'x5', ylab = 'f5')
# par(mfrow = c(1,1))
f = 5 * f1(x[,1]) + 3 * f2(x[,2]) + 4 * f3(x[,3]) + 6 * f4(x[,4]) + 4 * f5(x[,5])
# f = f1(x[,1]) + 2 * f2(x[,2]) + f3(x[,3]) + 2 * f4(x[,4]) +  f6(x[,5])
if(response == "regression"){
f = f + rnorm(n, 0, 1)
out = list(x = data.frame(x), y = f)
}
if(response == "classification"){
prob = exp(f)/(exp(f) + 1)
y = rbinom(n, 1, prob)
# plot(prob)
# print(table(y))
out = list(x = data.frame(x), f = f, y = y)
}
if(response == "count"){
mu = exp(f/sqrt(2)/p)
y = rpois(n, mu)
out = list(x = data.frame(x), f = f, y = y)
}
if(response == 'survival'){
# f = 2 * f1(x[,1]) + 1 * f2(x[,2]) + 1 * f3(x[,3]) + 2 * f4(x[,4]) + 1 * f5(x[,5])
f = 2 * f1(x[,1]) + 2 * f2(x[,2]) + 3 * f3(x[,3]) + 2 * f4(x[,4]) + 1 * f5(x[,5]) # 잘 된 세팅. 근데 FP구분을 못함
# f = 2 * f1(x[,1]) + 1 * f2(x[,2]) + 5 * f3(x[,3]) + 4 * f4(x[,4]) + 1 * f5(x[,5]) #두 번째 세팅
surTime = rexp(n, (exp(f)))
cenTime = rexp(n, (exp(-f) * runif(1, 8, 10)))
y = cbind(time = apply(cbind(surTime, cenTime), 1, min), status = 1 * (surTime < cenTime))
# mean(y[,"status"])
out = list(x = data.frame(x), f = f, y = y)
}
return(out)
}
fit3 = try(cdcosso(tr_x, tr_y, family = 'Cox', gamma = 1, kernel = "spline", scale = T, algo = "QP"), silent = TRUE)
set.seed(i)
tr = data_generation(n, p, response = "survival")
tr_x = tr$x
tr_y = tr$y
te = data_generation(te_n, p, response = "survival")
te_x = te$x
te_y = te$y
RS = RiskSet(te_y[,"time"], te_y[,"status"])
t1 = system.time({
fit3 = try(cdcosso(tr_x, tr_y, family = 'Cox', gamma = 1, kernel = "spline", scale = T, algo = "QP"), silent = TRUE)
})[3]  # lambda2를 크게 할수록  sparse, gamma를 크게 할수록 sparse
fit3
#' and generates a predicted value for the test data.
#' This function uses the given test data to calculate predictions from the weights and biases generated by the model.
#'
#' @param n The number of observation of a example dataset.
#' @param p Dimension of a example dataset.
#' @param rho Correlation for first five significance variables.
#' @param response Type of response variable.
#'
#' @return a list containing the predicted value for the test data (f.new) and the transformed value of that predicted value (mu.new).
#' @export
data_generation = function(n, p, rho,
response = c("regression", "classification", "count", "survival", "interaction")){
f1 = function(t) t - 0.5
f2 = function(t) (2 * t - 1)^2 - 0.4
f3 = function(t) sin(2 * pi * t) / (2 - sin(pi * t))
f4 = function(t) 0.1*sin(2 * pi * t) + 0.2*cos(2 * pi * t) + 0.3*sin(2 * pi * t)^2 + 0.4*cos(2 * pi * t)^2 + 0.5*sin(2 * pi * t)^3 - 0.4
f5 = function(t) sin(pi * t^4) + t^4 - 0.4
f6 = function(t) 3 * (3 * t - 2)^2 - 3
# f7 = function(t) 4 * cos((3 * t - 1.5) * pi / 5)
# f1 = function(t) 3*t - 1.5
# f2 = function(t) pi * sin(pi * t) - 2
# f3 = function(t) (cos(2 * t) + sin(7 * t)) - 0.5
# f4 = function(t) 2 * t^5 - 0.2
# f5 = function(t) (sin(6 * t)^{3} + cos(6 * t)^{9})
if(missing(response))
type = "classification"
response = match.arg(response)
if(missing(n)) n = 200
if(missing(p)) p = 10
if(missing(rho)) rho = 0.5
if(p <= 5) stop("dimension size should be larger than 5.")
Sigma = matrix(rho, 5, 5)
diag(Sigma) = 1
x_sig = pnorm(rmvnorm(n, sigma = Sigma))
x_nois = matrix(pnorm(rnorm(n * (p-5))), n, p-5)
x = cbind(x_sig, x_nois)
# Set the outer margins
# par(oma = c(0, 0, 0, 0))
# Set the inner margin
# par(mar = c(4, 4, 3, 1))
# par(mfrow = c(1,5))
# plot(x[,1], f1(x[,1]), cex = .6, pch = 16, xlab = 'x1', ylab = 'f1')
# plot(x[,2], f2(x[,2]), cex = .6, pch = 16, xlab = 'x2', ylab = 'f2')
# plot(x[,3], f3(x[,3]), cex = .6, pch = 16, xlab = 'x3', ylab = 'f3')
# plot(x[,4], f4(x[,4]), cex = .6, pch = 16, xlab = 'x4', ylab = 'f4')
# plot(x[,5], f5(x[,5]), cex = .6, pch = 16, xlab = 'x5', ylab = 'f5')
# par(mfrow = c(1,1))
f = 5 * f1(x[,1]) + 3 * f2(x[,2]) + 4 * f3(x[,3]) + 6 * f4(x[,4]) + 4 * f5(x[,5])
# f = f1(x[,1]) + 2 * f2(x[,2]) + f3(x[,3]) + 2 * f4(x[,4]) +  f6(x[,5])
if(response == "regression"){
f = f + rnorm(n, 0, 1)
out = list(x = data.frame(x), y = f)
}
if(response == "classification"){
prob = exp(f)/(exp(f) + 1)
y = rbinom(n, 1, prob)
# plot(prob)
# print(table(y))
out = list(x = data.frame(x), f = f, y = y)
}
if(response == "count"){
mu = exp(f/sqrt(2)/p)
y = rpois(n, mu)
out = list(x = data.frame(x), f = f, y = y)
}
if(response == 'survival'){
# f = 2 * f1(x[,1]) + 1 * f2(x[,2]) + 1 * f3(x[,3]) + 2 * f4(x[,4]) + 1 * f5(x[,5])
f = 1 * f1(x[,1]) + 1 * f2(x[,2]) + 1 * f3(x[,3]) + 1 * f4(x[,4]) + 1 * f5(x[,5]) # 잘 된 세팅. 근데 FP구분을 못함
# f = 2 * f1(x[,1]) + 1 * f2(x[,2]) + 5 * f3(x[,3]) + 4 * f4(x[,4]) + 1 * f5(x[,5]) #두 번째 세팅
surTime = rexp(n, (exp(f)))
cenTime = rexp(n, (exp(-f) * runif(1, 8, 10)))
y = cbind(time = apply(cbind(surTime, cenTime), 1, min), status = 1 * (surTime < cenTime))
# mean(y[,"status"])
out = list(x = data.frame(x), f = f, y = y)
}
return(out)
}
set.seed(i)
tr = data_generation(n, p, response = "survival")
tr_x = tr$x
tr_y = tr$y
te = data_generation(te_n, p, response = "survival")
te_x = te$x
te_y = te$y
RS = RiskSet(te_y[,"time"], te_y[,"status"])
t1 = system.time({
fit3 = try(cdcosso(tr_x, tr_y, family = 'Cox', gamma = 1, kernel = "spline", scale = T, algo = "QP"), silent = TRUE)
})[3]  # lambda2를 크게 할수록  sparse, gamma를 크게 할수록 sparse
fit3
x = tr_x
time = unlist(tr_y[, "time"])
status = unlist(tr_y[, "status"])
type = "spline"
algo = "CD"
family = 'Cox'
gamma = 0.95
kparam=1
lambda_theta = exp(seq(log(2^{-11}), log(2^{2}), length.out = 20))
wt = rep(1, ncol(x))
n = length(time)
p = length(wt)
K = make_anovaKernel(x, x, type = type, kparam, scale)
d = K$numK
# solve theta
getc_cvfit  = cv.getc(K, time, status, rep(1, d)/wt^2, lambda0, type, kparam, algo, show = TRUE)
theta_cvfit = cv.gettheta(getc_cvfit, x, time, status, wt, getc_cvfit$optlambda, lambda_theta, gamma, type, kparam, algo)
# solve (theta) - 2nd
theta.new = rescale_theta(theta_cvfit$theta.new)
print(theta.new)
cv.getc(K, time, status, theta.new/wt^2, lambda0, type, kparam, algo, show = TRUE)
print(theta.new)
library(compound.Cox)
data(PBC)
str(PBC)
X = PBC[,3:19]
y = cbind(PBC[,1:2])
names(y) = c("time", "status")
str(X)
X$trt <- as.factor(X$trt)
X$sex <- as.factor(X$sex)
X$asc <- as.factor(X$asc)
X$hep <- as.factor(X$hep)
X$spi <- as.factor(X$spi)
X$ede <- as.factor(X$ede)
### 실행 #######################################
i=1
iter = 10
time3 = time10 = c()
en3_varsel = en1_varsel = c()
en3_f1 = en1_f1 = en3_rec = en1_rec = en3_pre = en1_pre = c()
en3_miss = en1_miss = c()
en3_time = en1_time = c()
# split_id = train_test_split(y, 0.3)
# tr_x = X[split_id$train_id,]
# tr_y = y[split_id$train_id]
#
# te_x = X[split_id$test_id,]
# te_y = y[split_id$test_id]
n = nrow(X)
trainID = sample(1:n, size = floor(n * 0.7))
testID = (1:n)[-trainID]
tr_x = X[trainID, ]
tr_y = y[trainID,]
te_x = X[testID, ]
te_y = y[testID,]
t1 = system.time({
fit3 = try(cdcosso(tr_x, tr_y, family = 'Cox', gamma = 1, kernel = "spline", scale = T, algo = "QP"), silent = TRUE)
})  # lambda2를 크게 할수록  sparse, gamma를 크게 할수록 sparse
fit3
t2 = system.time({
fit10 = try(cdcosso(tr_x, tr_y, family = 'Cox', gamma = 0.95, kernel = "spline", scale = T,, algo = "CD"), silent = TRUE)
})  # lambda2를 크게 할수록  sparse, gamma를 크게 할수록 sparse
fit10
tr_x
str(tr_x)
