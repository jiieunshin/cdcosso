}
cw.new = cw.new
c.new = cw.new * sw
b.new = sum((zw - Rw %*% cw.new) * sw) / sum(sw)
return(list(Rw = Rw, z.new = z, zw.new = zw, w.new = w, sw.new = sw, b.new = b.new, c.new = c.new, cw.new = cw.new))
}
# cv.nng = function(model, y, mscale, lambda0, lambda_theta, gamma, obj, algo)
# {
#   cat("-- theta-step -- \n")
#   cat("proceeding... \n")
#   n = length(y)
#   d = length(mscale)
#
#   # solve theta
#   G <- matrix(0, nrow(model$R[, ,1]), d)
#   for (j in 1:d) {
#     G[, j] = model$R[, , j] %*% model$c.new * (mscale[j]^(-2))
#   }
#
#   Gw = G * sqrt(model$w.new)
#   uw = model$zw.new - model$b.new * sqrt(model$w.new) - (n/2) * lambda0 * model$cw.new
#
#   init.theta = rep(1, d)
#
#   len = length(lambda_theta)
#
#   measure <- c(NA, len)
#   save_theta <- list()
#
#
#   for (k in 1:len) {
#     if(algo == "CD") {
#       theta.new = .Call("glm_theta_step", Gw, uw, n, d, init.theta, lambda_theta[k], gamma)
#       # theta.new = nng.cd(Gw, uw, init.theta, lambda_theta[k], gamma)
#       theta.adj = ifelse(theta.new <= 1e-6, 0, theta.new)
#       save_theta[[k]] <- theta.adj
#     }
#
#     XX = model$zw.new - Gw %*% theta.adj
#     num = t(XX) %*% XX + 1
#     den = (1 - sum(diag( Gw %*% ginv( t(Gw) %*% Gw) %*% t(Gw) )) / n)^2 + 1
#     # measure[k] <- as.vector(num / den /n)
#
#     testfhat = G %*% theta.adj
#     testmu = obj$linkinv(testfhat)
#     measure[k] <- KL(testfhat, obj)
#   }
#
#
#   # plotting error bar
#   if(obj$family == 'gaussian'){
#     main = "Gaussian Family"
#   }
#   if(obj$family == 'binomial'){
#     main = "Binomial Family"
#   }
#   if(obj$family == 'poisson'){
#     main = "Poisson Family"
#   }
#
#   min_id = which.min(measure)
#   optlambda = lambda_theta[min_id]
#
#   ylab = expression("GCV(" * lambda[theta] * ")")
#
#   xrange = log(lambda_theta)
#   plot(xrange, measure, main = main, xlab = expression("Log(" * lambda[theta] * ")"), ylab = ylab, ylim = range(measure), pch = 15, col = 'red')
#
#   theta.new = .Call("glm_theta_step", Gw, uw, n, d, init.theta, optlambda, gamma)
#   # theta.new = nng.cd(Gw, uw, init.theta, optlambda, gamma)
#   # theta.new = save_theta[[id]]
#   theta.adj = ifelse(theta.new <= 1e-6, 0, theta.new)
#
#   f.new = c(G %*% theta.adj)
#   mu.new = obj$linkinv(f.new)
#
#   if(obj$family == "binomial") miss <- mean(y != ifelse(mu.new < 0.5, 0, 1))
#   if(obj$family == "gaussian") miss <- mean((y - f.new)^2)
#   if(obj$family == "poisson") miss <- mean(poisson()$dev.resids(y, mu.new, rep(1, n)))
#
#   cat("training error:", miss, "\n")
#
#   out = list(cv_error = measure, optlambda_theta = optlambda, gamma = gamma, theta.new = theta.new)
#   return(out)
# }
cv.nng = function(model, y, mscale, lambda0, lambda_theta, gamma, obj, algo)
{
cat("-- theta-step -- \n")
cat("proceeding... \n")
n = length(y)
d = length(mscale)
# solve theta
G <- matrix(0, nrow(model$R[, ,1]), d)
for (j in 1:d) {
G[, j] = model$R[, , j] %*% model$c.new * (mscale[j]^(-2))
}
Gw = G * sqrt(model$w.new)
uw = model$zw.new - model$b.new * sqrt(model$w.new) - (n/2) * lambda0 * model$cw.new
init.theta = rep(1, d)
if(algo == "QP") lambda_theta = exp(seq(log(1e-4), log(40), length.out = length(lambda_theta)))
len = length(lambda_theta)
measure <- matrix(NA, 5, len)
fold = cvsplitID(n, 5, y, family = obj$family)
save_theta <- list()
for(f in 1:5){
tr_id = as.vector(fold[, -f])
te_id = fold[, f]
tr_id = tr_id[!is.na(tr_id)]
te_id = te_id[!is.na(te_id)]
tr_n = length(tr_id)
te_n = length(te_id)
m = length(tr_id)
for (k in 1:len) {
theta.new = .Call("glm_theta_step", Gw[tr_id,], uw[tr_id], tr_n, d, init.theta, lambda_theta[k], gamma)
theta.adj = ifelse(theta.new <= 1e-6, 0, theta.new)
save_theta[[k]] <- theta.adj
testfhat = G[te_id, ] %*% theta.adj
testmu = obj$linkinv(testfhat)
# if(obj$family == "gaussian") measure[f, k] <- mean((testfhat - y[te_id])^2)
# if(obj$family == "binomial") measure[f, k] <- mean(y[te_id] != ifelse(testmu < 0.5, 0, 1))
# if(obj$family == "poisson") measure[f, k] <- mean(poisson()$dev.resids(y[te_id], testmu, rep(1, te_n)))
measure[f, k] <- KL(testfhat, obj)
}
}
# plotting error bar
if(obj$family == 'gaussian'){
main = "Gaussian Family"
}
if(obj$family == 'binomial'){
main = "Binomial Family"
}
if(obj$family == 'poisson'){
main = "Poisson Family"
}
measure_mean = colMeans(measure, na.rm = T)
measure_se = apply(measure, 2, sd, na.rm = T) / sqrt(te_n)
sel_id = which(!is.nan(measure_se) & measure_se != Inf)
measure_mean = measure_mean[sel_id]
measure_sd = measure_se[sel_id]
lambda_theta = lambda_theta[sel_id]
min_id = which.min(measure_mean)
cand_ids = which((measure_mean >= measure_mean[min_id]) &
(measure_mean <= (measure_mean[min_id] + measure_se[min_id])))
cand_ids = cand_ids[cand_ids >= min_id]
std_id = max(cand_ids)
optlambda = lambda_theta[std_id]
ylab = expression("GCV(" * lambda[theta] * ")")
xrange = log(lambda_theta)
# plot(xrange, measure, main = main, xlab = expression("Log(" * lambda[theta] * ")"), ylab = ylab, ylim = range(measure), pch = 15, col = 'red')
plot(log(lambda_theta), measure_mean, main = main, xlab = expression("Log(" * lambda[theta] * ")"), ylab = ylab,
ylim = range(c(measure_mean - measure_se, measure_mean + measure_se)), pch = 15, col = 'red')
arrows(x0 = log(lambda_theta), y0 = measure_mean - measure_se,
x1 = log(lambda_theta), y1 = measure_mean + measure_se,
angle = 90, code = 3, length = 0.1, col = "darkgray")
theta.new = .Call("glm_theta_step", Gw, uw, n, d, init.theta, optlambda, gamma)
# theta.new = save_theta[[id]]
theta.adj = ifelse(theta.new <= 1e-6, 0, theta.new)
f.new = c(G %*% theta.adj)
mu.new = obj$linkinv(f.new)
if(obj$family == "binomial") miss <- mean(y[te_id] != ifelse(mu.new < 0.5, 0, 1))
if(obj$family == "gaussian") miss <- mean((y[te_id] - f.new)^2)
if(obj$family == "poisson") miss <- mean(poisson()$dev.resids(y, mu.new, rep(1, te_n)))
cat("training error:", miss, "\n")
out = list(cv_error = measure, optlambda_theta = optlambda, gamma = gamma, theta.new = theta.new)
return(out)
}
nng.cd = function (Gw, uw, theta, lambda_theta, gamma)
{
n = nrow(Gw)
d = ncol(Gw)
r = lambda_theta * gamma * n
theta.new = rep(0, d)
for(i in 1:15){
for(j in 1:d){
theta.new[j] = 2 * sum((uw - Gw[,-j] %*% theta[-j]) * Gw[,j])
theta.new[j] = ifelse(theta.new[j] > 0 & r < abs(theta.new[j]), theta.new[j], 0)
theta.new[j] = theta.new[j] / (sum(Gw[,j]^2) + n * lambda_theta * (1-gamma)) / 2
loss = abs(theta - theta.new)
conv = max(loss) < 1e-20
if(conv) break
theta[j] = theta.new[j]
}
if(conv) break
}
if(i == 1 & !conv) theta = rep(0, d)
return(theta)
}
nng.QP = function (Gw, uw, theta, lambda_theta, gamma)
{
n = nrow(Gw)
d = ncol(Gw)
r = lambda_theta * gamma * n
theta.new = rep(0, d)
for(i in 1:15){ # outer iteration
Dmat = t(Gw) %*% Gw + diag(n * lambda_theta * gamma, d)
dvec = as.vector(2 * t(uw) %*% Gw)
Amat = t(rbind(diag(1, d), rep(-1, d)))
bvec = c(rep(0, d), -lambda_theta)
theta.new = solve.QP(2 * Dmat, dvec, Amat, bvec)$solution
theta.new[theta.new < 1e-8] = 0
loss = abs(theta - theta.new)
conv = max(loss) < 1e-8
if(conv) break
theta = theta.new
}
return(theta.new)
}
cdcosso.glm = function (x, y, wt, lambda0, lambda_theta, gamma, obj, type, kparam, scale, algo)
{
n = length(y)
p = length(wt)
cat("fit COSSO  with n = ", n, "p =", ncol(x), "\n")
K = make_anovaKernel(x, x, type = type, kparam, scale)
d = K$numK
cat("kernel:", type, "and d =", d, "\n")
par(mfrow = c(1,2))
# solve (theta) - 1st
sspline_cvfit = cv.sspline(K, y, rep(1, p)/wt^2, lambda0, obj, type, kparam, algo, show = TRUE) ## 초기값 설정. 수정할 함수
# solve (b, c) - 1st
nng_fit = cv.nng(sspline_cvfit, y, wt, sspline_cvfit$optlambda, lambda_theta, gamma, obj, algo)
theta.new = rescale_theta(nng_fit$theta.new)
# solve (theta) - 2nd
sspline_cvfit = try({cv.sspline(K, y, theta.new/wt^2, lambda0, obj, type, kparam, algo, show = TRUE)}) ## 초기값 설정. 수정할 함수
# nng_fit = cv.nng(sspline_cvfit, y, wt, sspline_cvfit$optlambda, lambda_theta, gamma, obj, algo)
par(mfrow = c(1,1))
if(algo == "CD")
out = list(data = list(x = x, y = y, R = sspline_cvfit$R, kernel = type, kparam = kparam),
tune = list(lambda0 = lambda0, lambda_theta = lambda_theta, gamma = gamma),
c_step = sspline_cvfit,
theta_step = nng_fit,
family = obj$family,
algorithm = algo)
if(algo == "QP")
out = list(data = list(x = x, y = y, R = sspline_cvfit$R, kernel = type, kparam = kparam),
tune = list(lambda0 = lambda0, lambda_theta = lambda_theta, gamma = gamma),
c_step = sspline_cvfit,
theta_step = nng_fit,
family = obj$family,
algorithm = algo)
return(out)
}
# gamma = 0.8
# type = "spline"
# one.std = TRUE
# scale = T
# wt = rep(1, ncol(x))
# kparam = 1
# nfolds =5
# algo = "CD"
# lambda0 = exp(seq(log(2^{-6}), log(2^{6}), length.out = 20))
# lambda_theta = exp(seq(log(2^{-6}), log(2^{6}), length.out = 20))
cdcosso = function (x,
y,
family = c("gaussian", "binomial", "poisson", "Cox"),
kernel = c("linear", "gaussian", "poly", "spline"),
effect = c("main", "interaction"),
algo = c("CD", "QP"),
kparam = 1,
lambda0 = exp(seq(log(2^{-11}), log(2^{2}), length.out = 20)),
lambda_theta = exp(seq(log(2^{-22}), log(2^{2}), length.out = 20)),
gamma = 0.95, scale = TRUE)
{
n = nrow(x)
colnames(x) = NULL
rownames(x) = NULL
# if(class(x)[1] != "data.frame")
# stop("A input x must be matrix")
# family
family = match.arg(family)
if(family == "gaussian")
obj = gaussian()
if(family == "binomial")
obj =  binomial()
if(family == "poisson")
obj = poisson()
if(missing(kernel))
type = 'spline'
else
type = match.arg(kernel)
if(missing(algo))
algo = "CD"
if(missing(effect))
effect = 'main'
else
effect = match.arg(kernel)
if(effect == "interaction") kernel = paste0(kernel, "2")
# if(missing(lambda0))
#   lambda0 = exp(seq(log(2^{-11}), log(2^{2}), length.out = 20))
#
# if(missing(lambda_theta))
#   lambda_theta = exp(seq(log(2^{-11}), log(2^{2}), length.out = 20))
if (family == "Cox" & !all(match(c("time", "status"), dimnames(y)[[2]], 0))) {
stop("Cox model requires a matrix with columns 'time' and 'status' as a response")
}
objnm = ifelse(family == 'gaussian' | family == 'binomial' | family == 'poisson', 'glm', family)
wt = rep(1, ncol(x))
# fitting
out = switch(objnm,
glm = cdcosso.glm(x, y, wt, lambda0, lambda_theta, gamma, obj, type, kparam, scale, algo),
Cox = cdcosso.cox(x, unlist(y[, "time"]), unlist(y[, "status"]), wt, lambda0, lambda_theta, gamma, type, kparam, scale, algo)
# Negbin, svm 추???
)
attr(out, "class") = "cdcosso"
return(out)
}
tr = data_generation(n, p, SNR = 15, response = "count")
tr_x = tr$x
tr_y = tr$y
fit3 = try(cdcosso(tr_x, tr_y, family = 'poisson', gamma = 1, kernel = "spline", scale = F, algo = "CD"), silent = TRUE)
fit10
mean(en1_f1)
d = length(fit3$theta_step$theta.new)
# true_var = c(rep(1, p_sig2, rep(0, d-p_sig2)))
true_var = c(rep(1, p_sig), rep(0, p-p_sig))
en3_signal_varsel[i, ] = ifelse(fit3$theta_step$theta.new[1:p_sig] > 0, 1, 0)
en3_true = ifelse(fit3$theta_step$theta.new > 0, 1, 0)
en3_varsel[i] = sum(en3_true)
en3_tp[i] = metric(true_var, en3_true)$tp
en3_fp[i] = metric(true_var, en3_true)$fp
en3_pre[i] = metric(true_var, en3_true)$precision
en3_rec[i] = metric(true_var, en3_true)$recall
en3_f1[i] = metric(true_var, en3_true)$f1_score
en3_pred = predict.cdcosso(fit3, te_x)
mean(poisson()$dev.resids(te_y, en3_pred$mu.new, rep(1, te_n)))
fit3 = try(cdcosso(tr_x, tr_y, family = 'poisson', gamma = 1, kernel = "spline", scale = F, algo = "CD"), silent = TRUE)
fit10
# true_var = c(rep(1, p_sig2, rep(0, d-p_sig2)))
true_var = c(rep(1, p_sig), rep(0, p-p_sig))
en3_signal_varsel[i, ] = ifelse(fit3$theta_step$theta.new[1:p_sig] > 0, 1, 0)
en3_true = ifelse(fit3$theta_step$theta.new > 0, 1, 0)
en3_varsel[i] = sum(en3_true)
en3_tp[i] = metric(true_var, en3_true)$tp
en3_fp[i] = metric(true_var, en3_true)$fp
en3_pre[i] = metric(true_var, en3_true)$precision
en3_rec[i] = metric(true_var, en3_true)$recall
en3_f1[i] = metric(true_var, en3_true)$f1_score
en3_pred = predict.cdcosso(fit3, te_x)
# en3_miss[i] = mean(te_y != ifelse(en3_pred$mu.new < 0.5, 0, 1))
# en3_miss[i] = mean((te_y - en3_pred$f.new)^2)
# en3_miss[i] = mean(KLD(te_y, en3_pred$f.new, poisson()))
en3_miss[i] = mean(poisson()$dev.resids(te_y, en3_pred$mu.new, rep(1, te_n)))
mean(poisson()$dev.resids(te_y, en3_pred$mu.new, rep(1, te_n)))
te
#' This function uses the given test data to calculate predictions from the weights and biases generated by the model.
#'
#' @param n The number of observation of a example dataset.
#' @param p Dimension of a example dataset.
#' @param rho Correlation for first five significance variables.
#' @param SNR Signal-to-noise ratio.
#' @param response Type of response variable.
#'
#' @return a list containing the predicted value for the test data (f.new) and the transformed value of that predicted value (mu.new).
#' @export
data_generation = function(n, p, rho, SNR,
response = c("regression", "classification", "count", "survival", "interaction")){
# if(response == "classification"){
# f1 = function(t) t - 0.5
# f2 = function(t) (2 * t - 1)^2 - 0.4
# f3 = function(t) sin(2 * pi * t) / (2 - sin(2 * pi * t))
# f4 = function(t) 0.1*sin(2 * pi * t) + 0.2*cos(2 * pi * t) + 0.3*sin(2 * pi * t)^2 + 0.4*cos(2 * pi * t)^3 + 0.5*sin(2 * pi * t)^3 - 0.2
# f5 = function(t) sin(pi * t^4) + t^4 - 0.6
# }
#
# if(response == "regression"){
# f1 = function(t) t
# f2 = function(t) (2 * t - 1)^2
# f3 = function(t) sin(2 * pi * t) / (2 - sin(2 * pi * t))
# f4 = function(t) 0.1*sin(2 * pi * t) + 0.2*cos(2 * pi * t) + 0.3*sin(2 * pi * t)^2 + 0.4*cos(2 * pi * t)^3 + 0.5*sin(2 * pi * t)^3
# f5 = function(t) sin(pi * t^4) + t^4
# }
f1 = function(t) 5 * sin(3*t) - 2
f2 = function(t) -4 * t^4 + 9.33 * t^3 + 5 * t^2 - 8.33 * t
f3 = function(t)  t * (1-t^2) * exp(3 * t) - 4
f4 = function(t) 4 * t
f5 = function(t) 4 * sin(-5 * log(sqrt(t+3)))
if(missing(response))
type = "classification"
response = match.arg(response)
if(missing(n)) n = 200
if(missing(p)) p = 10
if(missing(rho)) rho = 0.8
if(missing(SNR)) SNR = 8
if(p <= 5) stop("dimension size should be larger than 5.")
# Sigma = matrix(rho, 5, 5)
# diag(Sigma) = 1
Sigma = matrix(1, 5, 5)
for(j in 1:5){
for(k in 1:5){
Sigma[j, k] = rho^abs(j-k)
}
}
x = pnorm(rmvnorm(n, sigma = Sigma))
# t = 2
# x = matrix(runif(n * 5), n, 5)
# U = runif(n)
# for(j in 1:5){
#   x[, j] = (runif(n) + t * U)/(1 + t)
# }
# f = 5 * f1(x[,1]) + 3 * f2(x[,2]) + 4 * f3(x[,3]) + 6 * f4(x[,4])
# + 3 * f5(x[,5])
# print(f)
# V_sig = var(5 * f1(x[,1])) + var(3 * f2(x[,2])) + var(4 * f3(x[,3])) + var(6 * f4(x[,4]))
# sd = sqrt(V_sig / SNR)
f = f1(x[,1]) + f2(x[,2]) + f3(x[,3]) + f4(x[,4]) + f5(x[,5])
V_sig = var(f1(x[,1])) + var(f2(x[,2])) + var(f3(x[,3])) + var(f4(x[,4])) + var(f5(x[,5]))
sd = sqrt(var(f) / SNR)
print(sd)
x_nois = pnorm(matrix(rnorm(n * (p-5), 0, sd/sqrt(p-5)), n, (p-5)))
# x_nois = matrix(runif(n * (p-5)), n, (p-5))
x = cbind(x, x_nois)
# Set the outer margins
# par(oma = c(0, 0, 0, 0))
# Set the inner margin
# par(mar = c(4, 4, 3, 1))
# par(mfrow = c(1,5))
# plot(x[,1], f1(x[,1]), cex = .6, pch = 16, xlab = 'x1', ylab = 'f1')
# plot(x[,2], f2(x[,2]), cex = .6, pch = 16, xlab = 'x2', ylab = 'f2')
# plot(x[,3], f3(x[,3]), cex = .6, pch = 16, xlab = 'x3', ylab = 'f3')
# plot(x[,4], f4(x[,4]), cex = .6, pch = 16, xlab = 'x4', ylab = 'f4')
# plot(x[,5], f5(x[,5]), cex = .6, pch = 16, xlab = 'x5', ylab = 'f5')
# par(mfrow = c(1,1))
if(response == "regression"){
# SNR = sqrt(.6*(p-5)) # SNR = 4일 때
# print(SNR)
# f = f + rnorm(n, 0, sd)
out = list(x = x, y = f)
}
if(response == "classification"){
e = rnorm(n, 0, sd)
# f = f - 5
prob = exp(f)/(exp(f) + 1)
y = rbinom(n, 1, prob)
# plot(prob)
# print(table(y))
out = list(x = x, f = f, y = y)
}
if(response == "count"){
mu = exp(f/(2*sqrt(p)))
y = rpois(n, mu)
out = list(x = x, f = f, y = y)
}
if(response == 'survival'){
# Sigma = matrix(1, 8, 8)
# for(j in 1:8){
#   for(k in 1:8){
#     Sigma[j, k] = rho^abs(j-k)
#   }
# }
#
# x_sig = rtmvnorm(n, mean = rep(0, 8), sigma = Sigma, lower = rep(-2, 8), upper = rep(2, 8))
# x_nois = rtmvnorm(n, mean = rep(0, p-8), sigma = diag(1, p-8, p-8), lower = rep(-2, p-8), upper = rep(2, p-8))
# x = cbind(x_sig, x_nois)
# x = apply(x, 2, rescale)
# Sigma = matrix(1, 5, 5)
# for(j in 1:5){
#   for(k in 1:5){
#     Sigma[j, k] = rho^abs(j-k)
#   }
# }
#
# x_sig = rtmvnorm(n, mean = rep(0, 5), sigma = Sigma, lower = rep(-2, 5), upper = rep(2, 5))
# x_nois = rtmvnorm(n, mean = rep(0, p-5), sigma = diag(1, p-5, p-5), lower = rep(-2, p-5), upper = rep(2, p-5))
# x = cbind(x_sig, x_nois)
# x = apply(x, 2, rescale)
#
# f6 = function(t) cos(2 * pi * t) + sin(pi * t)
# f = 3 * (3 * x[, 1] - 2)^2 +  7 * cos((3 * x[, 3] - 1.5) * pi / 5) + ifelse(x[, 5] < 0.5, 0, 1) + 1 * f6(x[, 2]) + 11 * (exp(x[, 4]) - 3)
# f = 3 * (3 * x[, 1] - 2)^2 + 8 * cos((3 * x[, 3] - 1.5) * pi / 5) + ifelse(x[, 5] < 0.5, 0, 1) + 2 * f6(x[, 2]) + 11 * (exp(x[, 4]) - 2)
# f = 3 * (3 * x[, 1] - 2)^2 + 8 * cos((3 * x[, 3] - 1.5) * pi / 5) + 9 * (exp(x[, 5]) - 2) + 1 * f6(x[, 2]) + 5 * f4(x[, 4])
# SNR = sqrt(var(f) / 4)
# f = f + rnorm(n, 0, SNR)
surTime = rexp(n, exp(f))
cenTime = rexp(n, exp(-f) * runif(1, 4, 6))
y = cbind(time = apply(cbind(surTime, cenTime), 1, min), status = 1 * (surTime < cenTime))
# 14.003
# mean(tr_y[,"status"])
out = list(x = x, f = f, y = y)
}
return(out)
}
tr = data_generation(n, p, SNR = 15, response = "count")
tr_x = tr$x
tr_y = tr$y
te = data_generation(te_n, p, SNR = 15, response = "count")
te_x = te$x
te_y = te$y
tr_y
fit10 = try(cdcosso(tr_x, tr_y, family = 'poisson', gamma = 0.95, kernel = "spline", scale = F, algo = "CD"), silent = TRUE)
fit10
out = matrix(0, 18, 13)
colnames(out) = c("n", "p", "method", "tp", "tp_se", "fp", "fp_se", "f1", "f1_se", "miss", "miss_se", "time", "time_se")
out = data.frame(out)
i=1
ll = 0
te = data_generation(te_n, p, SNR = 15, response = "count")
te_x = te$x
te_y = te$y
# true_var = c(rep(1, p_sig2, rep(0, d-p_sig2)))
true_var = c(rep(1, p_sig), rep(0, p-p_sig))
en3_signal_varsel[i, ] = ifelse(fit3$theta_step$theta.new[1:p_sig] > 0, 1, 0)
en3_true = ifelse(fit3$theta_step$theta.new > 0, 1, 0)
en3_varsel[i] = sum(en3_true)
en3_tp[i] = metric(true_var, en3_true)$tp
en3_fp[i] = metric(true_var, en3_true)$fp
en3_pre[i] = metric(true_var, en3_true)$precision
en3_rec[i] = metric(true_var, en3_true)$recall
en3_f1[i] = metric(true_var, en3_true)$f1_score
en3_pred = predict.cdcosso(fit3, te_x)
mean(poisson()$dev.resids(te_y, en3_pred$mu.new, rep(1, te_n)))
en3_pred$mu.new
poisson()$dev.resids(te_y, en3_pred$mu.new
poisson()$dev.resids
