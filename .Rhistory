}
}
}
# print(f.init)
# print(mean(y == ifelse(obj$linkinv(aaa) < 0.5, 0, 1)))
measure <- matrix(NA, ncol = length(cand.lambda), nrow = nfolds)
bmat <- matrix(NA, ncol = length(cand.lambda), nrow = nfolds)
for (f in 1:nfolds) {
print(f)
testID <- IDmat[!is.na(IDmat[, f]), f]
trainID <- (1:n)[-testID]
# generate SS-ANOVA
tr_n = length(trainID)
te_n = length(testID)
tr_R = array(NA, c(tr_n, tr_n, d))
te_R = array(NA, c(te_n, tr_n, d))
for(j in 1:d){
tr_R[, , j] = K$K[[j]][trainID, trainID]
te_R[, , j] = K$K[[j]][testID, trainID]
}
tr_Rtheta <- wsGram(tr_R, mscale)
te_Rtheta <- wsGram(te_R, mscale)
for (k in 1:length(cand.lambda)) {
print(k)
if(algo == "CD"){
# initialize
ff = f.init[trainID]
mu = obj$linkinv(ff)
w = obj$variance(mu)
z = ff + (y[trainID] - mu) / w
b = 0
# print(b)
c.init = as.vector(glmnet(tr_Rtheta, y[trainID], family = 'gaussian', lambda = cand.lambda[k])$beta)
# c.init = rep(1, tr_n)
zw = z * sqrt(w)
Rw = tr_Rtheta * w
cw = c.init / sqrt(w)
sw = sqrt(w)
sspline_fit = sspline.cd(tr_Rtheta, y[trainID], ff, cand.lambda[k], obj, c.init)
# print(c(tr_Rtheta %*% sspline_fit$c.new) + sspline_fit$b.new)
# sspline_fit = .Call("Csspline", zw, Rw, cw, sw, tr_n, cand.lambda[k], PACKAGE = "cdcosso")
b.new = sspline_fit$b.new
c.new = sspline_fit$c.new
cw.new = sspline_fit$cw.new
print(b.new)
}
if(algo == "QP"){
sspline_fit = sspline.QP(tr_Rtheta, y[trainID], f.init[trainID], cand.lambda[k], obj, c.init[trainID])
b.new = sspline_fit$b.new
c.new = sspline_fit$c.new
cw.new = sspline_fit$cw.new
}
if(sum(is.nan(cw.new)) == tr_n){
next
} else{
# validation
# f.new <- fit$f.new
testfhat = c(b.new + te_Rtheta %*% c.new)
testmu = obj$linkinv(testfhat)
testw = obj$variance(testmu)
w.new = sspline_fit$sw.new^2
XX = sspline_fit$zw.new - (tr_Rtheta * w.new) %*% cw.new - sspline_fit$sw.new
den = (1 - sum(diag(tr_Rtheta %*% ginv(tr_Rtheta + diag(w.new)/cand.lambda[k]))) / tr_n)^2
bmat[f,k] <- b.new
measure[f, k] <- as.vector((t(XX) %*% XX) / den / tr_n)
print(measure[f, k] )
# testz = testfhat + (y[testID] - testmu) / testw
#
# testzw = testz * sqrt(testw)
# testRw = te_Rtheta * testw
# rss <- t(testzw - testRw %*% cw.new - b.new * sqrt(testw)) %*% (testzw - testRw %*% cw.new - b.new * sqrt(testw)) + .1
# S = testRw %*% ginv(t(testRw) %*% testRw) %*% t(testRw)
# df = sum(diag(S))
# measure[f, k] <- rss / (1 - df/length(testID) + .1)^2 / length(testID)
# if(obj$family == "poisson") measure[f, k] <- mean(obj$dev.resids(y[testID], testmu, testw)) + t(c.new) %*% tr_Rtheta %*% c.new * tr_n * cand.lambda[k]
# if(obj$family == "binomial") measure[f, k] <- mean(ifelse(testmu < 0.5, 0, 1) != y[testID])
# if(obj$family == "gaussian") measure[f, k] <- mean((testmu - y[testID])^2)
# if(obj$family == "poisson") measure[f, k] <- mean(KLD(testfhat, y[testID], obj))
}
}
}
sspline_fit
c.init
XX = sspline_fit$zw.new - (tr_Rtheta * w.new) %*% cw.new - sspline_fit$sw.new
sspline_fit$zw.new
z
w
ff
obj$linkinv(ff)
mean(y)
if(obj$family == "poisson") f.init = rep(1, n)
# print(f.init)
# print(mean(y == ifelse(obj$linkinv(aaa) < 0.5, 0, 1)))
measure <- matrix(NA, ncol = length(cand.lambda), nrow = nfolds)
bmat <- matrix(NA, ncol = length(cand.lambda), nrow = nfolds)
for (f in 1:nfolds) {
print(f)
testID <- IDmat[!is.na(IDmat[, f]), f]
trainID <- (1:n)[-testID]
# generate SS-ANOVA
tr_n = length(trainID)
te_n = length(testID)
tr_R = array(NA, c(tr_n, tr_n, d))
te_R = array(NA, c(te_n, tr_n, d))
for(j in 1:d){
tr_R[, , j] = K$K[[j]][trainID, trainID]
te_R[, , j] = K$K[[j]][testID, trainID]
}
tr_Rtheta <- wsGram(tr_R, mscale)
te_Rtheta <- wsGram(te_R, mscale)
for (k in 1:length(cand.lambda)) {
print(k)
if(algo == "CD"){
# initialize
ff = f.init[trainID]
mu = obj$linkinv(ff)
w = obj$variance(mu)
z = ff + (y[trainID] - mu) / w
b = 0
# print(b)
c.init = as.vector(glmnet(tr_Rtheta, y[trainID], family = 'gaussian', lambda = cand.lambda[k])$beta)
# c.init = rep(1, tr_n)
zw = z * sqrt(w)
Rw = tr_Rtheta * w
cw = c.init / sqrt(w)
sw = sqrt(w)
sspline_fit = sspline.cd(tr_Rtheta, y[trainID], ff, cand.lambda[k], obj, c.init)
# print(c(tr_Rtheta %*% sspline_fit$c.new) + sspline_fit$b.new)
# sspline_fit = .Call("Csspline", zw, Rw, cw, sw, tr_n, cand.lambda[k], PACKAGE = "cdcosso")
b.new = sspline_fit$b.new
c.new = sspline_fit$c.new
cw.new = sspline_fit$cw.new
print(b.new)
}
if(algo == "QP"){
sspline_fit = sspline.QP(tr_Rtheta, y[trainID], f.init[trainID], cand.lambda[k], obj, c.init[trainID])
b.new = sspline_fit$b.new
c.new = sspline_fit$c.new
cw.new = sspline_fit$cw.new
}
if(sum(is.nan(cw.new)) == tr_n){
next
} else{
# validation
# f.new <- fit$f.new
testfhat = c(b.new + te_Rtheta %*% c.new)
testmu = obj$linkinv(testfhat)
testw = obj$variance(testmu)
w.new = sspline_fit$sw.new^2
XX = sspline_fit$zw.new - (tr_Rtheta * w.new) %*% cw.new - sspline_fit$sw.new
den = (1 - sum(diag(tr_Rtheta %*% ginv(tr_Rtheta + diag(w.new)/cand.lambda[k]))) / tr_n)^2
bmat[f,k] <- b.new
measure[f, k] <- as.vector((t(XX) %*% XX) / den / tr_n)
print(measure[f, k] )
# testz = testfhat + (y[testID] - testmu) / testw
#
# testzw = testz * sqrt(testw)
# testRw = te_Rtheta * testw
# rss <- t(testzw - testRw %*% cw.new - b.new * sqrt(testw)) %*% (testzw - testRw %*% cw.new - b.new * sqrt(testw)) + .1
# S = testRw %*% ginv(t(testRw) %*% testRw) %*% t(testRw)
# df = sum(diag(S))
# measure[f, k] <- rss / (1 - df/length(testID) + .1)^2 / length(testID)
# if(obj$family == "poisson") measure[f, k] <- mean(obj$dev.resids(y[testID], testmu, testw)) + t(c.new) %*% tr_Rtheta %*% c.new * tr_n * cand.lambda[k]
# if(obj$family == "binomial") measure[f, k] <- mean(ifelse(testmu < 0.5, 0, 1) != y[testID])
# if(obj$family == "gaussian") measure[f, k] <- mean((testmu - y[testID])^2)
# if(obj$family == "poisson") measure[f, k] <- mean(KLD(testfhat, y[testID], obj))
}
}
}
measure[measure == -Inf | measure == Inf | is.nan(measure)] <- NA
if(sum(is.na(measure)) == length(cand.lambda) * nfolds){
conv = FALSE
return(list(conv = conv))
}
rm(tr_Rtheta)
rm(te_Rtheta)
cvm <- apply(measure, 2, mean, na.rm = T)
cvsd <- apply(measure, 2, sd, na.rm = T) / sqrt(nrow(measure)) + 1e-22
cvsd[cvsd == Inf] <- NA
# optimal lambda1
id = which.min(cvm)[1]
optlambda = cand.lambda[id]
# if(one.std){
# st1_err = cvm[id] + cvsd[id] # minimum cv err
# std.id = max(which(cvm[1:id] <= st1_err & cvm[1:id] <= cvm[id]))
# std.id = ifelse(std.id > id, std.id, id)
# optlambda = cand.lambda[std.id]
# } else{
#   optlambda = cand.lambda[id]
# }
#
# plotting error bar
if(obj$family == 'gaussian'){
main = "Gaussian Family"
}
if(obj$family == 'binomial'){
main = "Binomial Family"
}
if(obj$family == 'poisson'){
main = "Poisson Family"
}
max_min <- c(min(cvm - cvsd, na.rm = T), max(cvm + cvsd, na.rm = T))
plot(log(cand.lambda), cvm, main = main, xlab = expression("Log(" * lambda[0] * ")"), ylab = "generalized cross validation", ylim = max_min, type = 'n')
try(arrows(log(cand.lambda), cvm - cvsd, log(cand.lambda), cvm + cvsd, angle = 90, length = 0.01, col = 'gray'), silent = TRUE)
points(log(cand.lambda), cvm, pch = 15, col = 'red')
abline(v = log(cand.lambda)[id], col = 'darkgrey', lty = 2)
if(obj$family == "poisson") f.init = rep(0.5, n)  # 추정에 이 초기값 영향도 있음
# print(f.init)
# print(mean(y == ifelse(obj$linkinv(aaa) < 0.5, 0, 1)))
measure <- matrix(NA, ncol = length(cand.lambda), nrow = nfolds)
bmat <- matrix(NA, ncol = length(cand.lambda), nrow = nfolds)
for (f in 1:nfolds) {
print(f)
testID <- IDmat[!is.na(IDmat[, f]), f]
trainID <- (1:n)[-testID]
# generate SS-ANOVA
tr_n = length(trainID)
te_n = length(testID)
tr_R = array(NA, c(tr_n, tr_n, d))
te_R = array(NA, c(te_n, tr_n, d))
for(j in 1:d){
tr_R[, , j] = K$K[[j]][trainID, trainID]
te_R[, , j] = K$K[[j]][testID, trainID]
}
tr_Rtheta <- wsGram(tr_R, mscale)
te_Rtheta <- wsGram(te_R, mscale)
for (k in 1:length(cand.lambda)) {
print(k)
if(algo == "CD"){
# initialize
ff = f.init[trainID]
mu = obj$linkinv(ff)
w = obj$variance(mu)
z = ff + (y[trainID] - mu) / w
b = 0
# print(b)
c.init = as.vector(glmnet(tr_Rtheta, y[trainID], family = 'gaussian', lambda = cand.lambda[k])$beta)
# c.init = rep(1, tr_n)
zw = z * sqrt(w)
Rw = tr_Rtheta * w
cw = c.init / sqrt(w)
sw = sqrt(w)
sspline_fit = sspline.cd(tr_Rtheta, y[trainID], ff, cand.lambda[k], obj, c.init)
# print(c(tr_Rtheta %*% sspline_fit$c.new) + sspline_fit$b.new)
# sspline_fit = .Call("Csspline", zw, Rw, cw, sw, tr_n, cand.lambda[k], PACKAGE = "cdcosso")
b.new = sspline_fit$b.new
c.new = sspline_fit$c.new
cw.new = sspline_fit$cw.new
print(b.new)
}
if(algo == "QP"){
sspline_fit = sspline.QP(tr_Rtheta, y[trainID], f.init[trainID], cand.lambda[k], obj, c.init[trainID])
b.new = sspline_fit$b.new
c.new = sspline_fit$c.new
cw.new = sspline_fit$cw.new
}
if(sum(is.nan(cw.new)) == tr_n){
next
} else{
# validation
# f.new <- fit$f.new
testfhat = c(b.new + te_Rtheta %*% c.new)
testmu = obj$linkinv(testfhat)
testw = obj$variance(testmu)
w.new = sspline_fit$sw.new^2
XX = sspline_fit$zw.new - (tr_Rtheta * w.new) %*% cw.new - sspline_fit$sw.new
den = (1 - sum(diag(tr_Rtheta %*% ginv(tr_Rtheta + diag(w.new)/cand.lambda[k]))) / tr_n)^2
bmat[f,k] <- b.new
measure[f, k] <- as.vector((t(XX) %*% XX) / den / tr_n)
print(measure[f, k] )
# testz = testfhat + (y[testID] - testmu) / testw
#
# testzw = testz * sqrt(testw)
# testRw = te_Rtheta * testw
# rss <- t(testzw - testRw %*% cw.new - b.new * sqrt(testw)) %*% (testzw - testRw %*% cw.new - b.new * sqrt(testw)) + .1
# S = testRw %*% ginv(t(testRw) %*% testRw) %*% t(testRw)
# df = sum(diag(S))
# measure[f, k] <- rss / (1 - df/length(testID) + .1)^2 / length(testID)
# if(obj$family == "poisson") measure[f, k] <- mean(obj$dev.resids(y[testID], testmu, testw)) + t(c.new) %*% tr_Rtheta %*% c.new * tr_n * cand.lambda[k]
# if(obj$family == "binomial") measure[f, k] <- mean(ifelse(testmu < 0.5, 0, 1) != y[testID])
# if(obj$family == "gaussian") measure[f, k] <- mean((testmu - y[testID])^2)
# if(obj$family == "poisson") measure[f, k] <- mean(KLD(testfhat, y[testID], obj))
}
}
}
measure[measure == -Inf | measure == Inf | is.nan(measure)] <- NA
if(sum(is.na(measure)) == length(cand.lambda) * nfolds){
conv = FALSE
return(list(conv = conv))
}
rm(tr_Rtheta)
rm(te_Rtheta)
cvm <- apply(measure, 2, mean, na.rm = T)
cvsd <- apply(measure, 2, sd, na.rm = T) / sqrt(nrow(measure)) + 1e-22
cvsd[cvsd == Inf] <- NA
# optimal lambda1
id = which.min(cvm)[1]
optlambda = cand.lambda[id]
# if(one.std){
# st1_err = cvm[id] + cvsd[id] # minimum cv err
# std.id = max(which(cvm[1:id] <= st1_err & cvm[1:id] <= cvm[id]))
# std.id = ifelse(std.id > id, std.id, id)
# optlambda = cand.lambda[std.id]
# } else{
#   optlambda = cand.lambda[id]
# }
#
# plotting error bar
if(obj$family == 'gaussian'){
main = "Gaussian Family"
}
if(obj$family == 'binomial'){
main = "Binomial Family"
}
if(obj$family == 'poisson'){
main = "Poisson Family"
}
max_min <- c(min(cvm - cvsd, na.rm = T), max(cvm + cvsd, na.rm = T))
plot(log(cand.lambda), cvm, main = main, xlab = expression("Log(" * lambda[0] * ")"), ylab = "generalized cross validation", ylim = max_min, type = 'n')
try(arrows(log(cand.lambda), cvm - cvsd, log(cand.lambda), cvm + cvsd, angle = 90, length = 0.01, col = 'gray'), silent = TRUE)
points(log(cand.lambda), cvm, pch = 15, col = 'red')
abline(v = log(cand.lambda)[id], col = 'darkgrey', lty = 2)
# print(f.init)
# print(mean(y == ifelse(obj$linkinv(aaa) < 0.5, 0, 1)))
measure <- matrix(NA, ncol = length(cand.lambda), nrow = nfolds)
bmat <- matrix(NA, ncol = length(cand.lambda), nrow = nfolds)
for (f in 1:nfolds) {
print(f)
testID <- IDmat[!is.na(IDmat[, f]), f]
trainID <- (1:n)[-testID]
# generate SS-ANOVA
tr_n = length(trainID)
te_n = length(testID)
tr_R = array(NA, c(tr_n, tr_n, d))
te_R = array(NA, c(te_n, tr_n, d))
for(j in 1:d){
tr_R[, , j] = K$K[[j]][trainID, trainID]
te_R[, , j] = K$K[[j]][testID, trainID]
}
tr_Rtheta <- wsGram(tr_R, mscale)
te_Rtheta <- wsGram(te_R, mscale)
for (k in 1:length(cand.lambda)) {
print(k)
if(algo == "CD"){
# initialize
ff = f.init[trainID]
mu = obj$linkinv(ff)
w = obj$variance(mu)
z = ff + (y[trainID] - mu) / w
b = 0
# print(b)
c.init = as.vector(glmnet(tr_Rtheta, y[trainID], family = 'gaussian', lambda = cand.lambda[k])$beta)
# c.init = rep(1, tr_n)
zw = z * sqrt(w)
Rw = tr_Rtheta * w
cw = c.init / sqrt(w)
sw = sqrt(w)
sspline_fit = sspline.cd(tr_Rtheta, y[trainID], ff, cand.lambda[k], obj, c.init)
# print(c(tr_Rtheta %*% sspline_fit$c.new) + sspline_fit$b.new)
# sspline_fit = .Call("Csspline", zw, Rw, cw, sw, tr_n, cand.lambda[k], PACKAGE = "cdcosso")
b.new = sspline_fit$b.new
c.new = sspline_fit$c.new
cw.new = sspline_fit$cw.new
print(b.new)
}
if(algo == "QP"){
sspline_fit = sspline.QP(tr_Rtheta, y[trainID], f.init[trainID], cand.lambda[k], obj, c.init[trainID])
b.new = sspline_fit$b.new
c.new = sspline_fit$c.new
cw.new = sspline_fit$cw.new
}
if(sum(is.nan(cw.new)) == tr_n){
next
} else{
# validation
# testfhat = c(b.new + te_Rtheta %*% c.new)
# testmu = obj$linkinv(testfhat)
# testw = obj$variance(testmu)
w.new = sspline_fit$sw.new^2
XX = sspline_fit$zw.new - (tr_Rtheta * w.new) %*% cw.new - sspline_fit$sw.new
den = (1 - sum(diag(tr_Rtheta %*% ginv(tr_Rtheta + diag(w.new)/cand.lambda[k]))) / tr_n)^2
bmat[f,k] <- b.new
measure[f, k] <- as.vector((t(XX) %*% XX) / den / tr_n)
print(measure[f, k] )
# testz = testfhat + (y[testID] - testmu) / testw
#
# testzw = testz * sqrt(testw)
# testRw = te_Rtheta * testw
# rss <- t(testzw - testRw %*% cw.new - b.new * sqrt(testw)) %*% (testzw - testRw %*% cw.new - b.new * sqrt(testw)) + .1
# S = testRw %*% ginv(t(testRw) %*% testRw) %*% t(testRw)
# df = sum(diag(S))
# measure[f, k] <- rss / (1 - df/length(testID) + .1)^2 / length(testID)
# if(obj$family == "poisson") measure[f, k] <- mean(obj$dev.resids(y[testID], testmu, testw)) + t(c.new) %*% tr_Rtheta %*% c.new * tr_n * cand.lambda[k]
# if(obj$family == "binomial") measure[f, k] <- mean(ifelse(testmu < 0.5, 0, 1) != y[testID])
# if(obj$family == "gaussian") measure[f, k] <- mean((testmu - y[testID])^2)
# if(obj$family == "poisson") measure[f, k] <- mean(KLD(testfhat, y[testID], obj))
}
}
}
# print(f.init)
# print(mean(y == ifelse(obj$linkinv(aaa) < 0.5, 0, 1)))
measure <- matrix(NA, ncol = length(cand.lambda), nrow = nfolds)
bmat <- matrix(NA, ncol = length(cand.lambda), nrow = nfolds)
for (f in 1:nfolds) {
print(f)
testID <- IDmat[!is.na(IDmat[, f]), f]
trainID <- (1:n)[-testID]
# generate SS-ANOVA
tr_n = length(trainID)
te_n = length(testID)
tr_R = array(NA, c(tr_n, tr_n, d))
te_R = array(NA, c(te_n, tr_n, d))
for(j in 1:d){
tr_R[, , j] = K$K[[j]][trainID, trainID]
te_R[, , j] = K$K[[j]][testID, trainID]
}
tr_Rtheta <- wsGram(tr_R, mscale)
te_Rtheta <- wsGram(te_R, mscale)
for (k in 1:length(cand.lambda)) {
print(k)
if(algo == "CD"){
# initialize
ff = f.init[trainID]
mu = obj$linkinv(ff)
w = obj$variance(mu)
z = ff + (y[trainID] - mu) / w
b = 0
# print(b)
c.init = as.vector(glmnet(tr_Rtheta, y[trainID], family = 'gaussian', lambda = cand.lambda[k])$beta)
# c.init = rep(1, tr_n)
zw = z * sqrt(w)
Rw = tr_Rtheta * w
cw = c.init / sqrt(w)
sw = sqrt(w)
# sspline_fit = sspline.cd(tr_Rtheta, y[trainID], ff, cand.lambda[k], obj, c.init)
# print(c(tr_Rtheta %*% sspline_fit$c.new) + sspline_fit$b.new)
sspline_fit = .Call("Csspline", zw, Rw, cw, sw, tr_n, cand.lambda[k], PACKAGE = "cdcosso")
b.new = sspline_fit$b.new
c.new = sspline_fit$c.new
cw.new = sspline_fit$cw.new
print(b.new)
}
if(algo == "QP"){
sspline_fit = sspline.QP(tr_Rtheta, y[trainID], f.init[trainID], cand.lambda[k], obj, c.init[trainID])
b.new = sspline_fit$b.new
c.new = sspline_fit$c.new
cw.new = sspline_fit$cw.new
}
if(sum(is.nan(cw.new)) == tr_n){
next
} else{
# validation
# testfhat = c(b.new + te_Rtheta %*% c.new)
# testmu = obj$linkinv(testfhat)
# testw = obj$variance(testmu)
w.new = sspline_fit$sw.new^2
XX = sspline_fit$zw.new - (tr_Rtheta * w.new) %*% cw.new - sspline_fit$sw.new
den = (1 - sum(diag(tr_Rtheta %*% ginv(tr_Rtheta + diag(w.new)/cand.lambda[k]))) / tr_n)^2
bmat[f,k] <- b.new
measure[f, k] <- as.vector((t(XX) %*% XX) / den / tr_n)
print(measure[f, k] )
# testz = testfhat + (y[testID] - testmu) / testw
#
# testzw = testz * sqrt(testw)
# testRw = te_Rtheta * testw
# rss <- t(testzw - testRw %*% cw.new - b.new * sqrt(testw)) %*% (testzw - testRw %*% cw.new - b.new * sqrt(testw)) + .1
# S = testRw %*% ginv(t(testRw) %*% testRw) %*% t(testRw)
# df = sum(diag(S))
# measure[f, k] <- rss / (1 - df/length(testID) + .1)^2 / length(testID)
# if(obj$family == "poisson") measure[f, k] <- mean(obj$dev.resids(y[testID], testmu, testw)) + t(c.new) %*% tr_Rtheta %*% c.new * tr_n * cand.lambda[k]
# if(obj$family == "binomial") measure[f, k] <- mean(ifelse(testmu < 0.5, 0, 1) != y[testID])
# if(obj$family == "gaussian") measure[f, k] <- mean((testmu - y[testID])^2)
# if(obj$family == "poisson") measure[f, k] <- mean(KLD(testfhat, y[testID], obj))
}
}
}
ff
mu
w
c.init
zw
Rw
cw
sw
.Call("Csspline", zw, Rw, cw, sw, tr_n, cand.lambda[k], PACKAGE = "cdcosso")
sspline_fit = sspline.cd(tr_Rtheta, y[trainID], ff, cand.lambda[k], obj, c.init)
sspline_fit$b.new
.Call("Csspline", zw, Rw, cw, sw, tr_n, cand.lambda[k], PACKAGE = "cdcosso")
sspline.cd
library(camerondata)
data(randhealth)
df = na.omit(randhealth)
X = df[1:2000,-1]
y = df[1:2000,1]
str(X)
### 실행 #######################################
devtools::install_github("jiieunshin/cdcosso")
library(cdcosso)
i=1
iter = 10
time3 = time10 = c()
en3_varsel = en1_varsel = c()
en3_f1 = en1_f1 = en3_rec = en1_rec = en3_pre = en1_pre = c()
en3_miss = en1_miss = c()
en3_time = en1_time = c()
cat("\n iteration :", i, "\n")
set.seed(i)
split_id = train_test_split(y, 0.3)
tr_x = X[split_id$train_id,]
tr_y = y[split_id$train_id]
te_x = X[split_id$test_id,]
te_y = y[split_id$test_id]
