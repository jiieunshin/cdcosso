cat('f1     :', round(mean(en1_f1, na.rm = TRUE), 4), "(", round(sd(en1_f1, na.rm = TRUE)/sqrt(sum(!is.na(en1_f1))), 4), ")", "\n")
cat('miss   :', round(mean(en1_miss, na.rm = TRUE), 4), "(", round(sd(en1_miss, na.rm = TRUE)/sqrt(sum(!is.na(en1_miss))), 4), ")", "\n")
# cat('time   :', round(mean(time10, na.rm = TRUE), 4), "(", round(sd(time10, na.rm = TRUE)/sqrt(sum(!is.na(time10))), 4), ")", "\n")
}
}
#'
#' The predict.cdcosso function is a function that receives the object and test data (testx) of the cdcosso package as input
#' and generates a predicted value for the test data.
#' This function uses the given test data to calculate predictions from the weights and biases generated by the model.
#'
#' @param y Model object fitted from the cdcosso package.
#' @param test_percent The test data you want to predict.
#'
#' @return a list containing the predicted value for the test data (f.new) and the transformed value of that predicted value (mu.new).
#' @export
train_test_split = function(y, test_percent){
y = as.numeric(as.factor(y))
tb = table(y)
uniq_label = as.numeric(names(tb))
num = floor(tb * test_percent)
test_id = c()
for(i in 1:length(tb)){
test_id = c(test_id, sort(sample(which(y == i), num[i], replace = FALSE)))
}
out = list()
out$train_id = which(!((1:length(y)) %in% test_id))
out$test_id = which((1:length(y)) %in% test_id)
return(out)
}
tr = data_generation(n, p, response = "classification")
tr_x = tr$x
tr_y = tr$y
train_test_split(tr_y, 0.7)
tr_y
#' This function uses the given test data to calculate predictions from the weights and biases generated by the model.
#'
#' @param n The number of observation of a example dataset.
#' @param p Dimension of a example dataset.
#' @param rho Correlation for first five significance variables.
#' @param SNR Signal-to-noise ratio.
#' @param response Type of response variable.
#'
#' @return a list containing the predicted value for the test data (f.new) and the transformed value of that predicted value (mu.new).
#' @export
data_generation = function(n, p, rho, SNR,
response = c("regression", "classification", "count", "survival", "interaction")){
# f1 = function(t) t - 0.5
# f2 = function(t) (2 * t - 1)^2 - 0.4
# f3 = function(t) sin(2 * pi * t) / (2 - sin(pi * t))
# f4 = function(t) 0.1*sin(2 * pi * t) + 0.2*cos(2 * pi * t) + 0.3*sin(2 * pi * t)^2 + 0.4*cos(2 * pi * t)^2 + 0.5*sin(2 * pi * t)^3 - 0.4
# f5 = function(t) sin(pi * t^4) + t^4 - 0.4
f1 = function(t) 5 * sin(3*t)
f2 = function(t) -4 * t^4 + 9.33 * t^3 + 5 * t^2 - 8.33 * t
f3 = function(t)  t * (1-t^2) * exp(3 * t) - 4
f4 = function(t) 4 * t
f5 = function(t) 4 * sin(-5 * log(sqrt(t+3)))
if(missing(response))
type = "classification"
response = match.arg(response)
if(missing(n)) n = 200
if(missing(p)) p = 10
if(missing(rho)) rho = 0.8
if(missing(SNR)) SNR = 2
if(p <= 5) stop("dimension size should be larger than 5.")
Sigma = matrix(rho, 5, 5)
diag(Sigma) = 1
# Sigma = matrix(1, 5, 5)
# for(j in 1:5){
#   for(k in 1:5){
#     Sigma[j, k] = rho^abs(j-k)
#   }
# }
x = pnorm(rmvnorm(n, sigma = Sigma))
# x = matrix(0, n, 5)
# x[, 1] = runif(n)
# U = runif(n)
# for(j in 2:5){
#   x[, j] = (runif(n) + 2 * U)/(1 + 2)
# }
# f = 5 * f1(x[,1]) + 2 * f2(x[,2]) + 3 * f3(x[,3]) + 6 * f4(x[,4]) + 4 * f5(x[,5])
# V_sig = var(5 * f1(x[,1])) + var(2 * f2(x[,2])) + var(3 * f3(x[,3])) + var(6 * f4(x[,4])) + var(4 * f5(x[,5]))
# sd = sqrt(V_sig / (p-5) / SNR)
f = f1(x[,1]) + f2(x[,2]) + f3(x[,3]) + f4(x[,4]) + f5(x[,5])
V_sig = var(f1(x[,1])) + var(f2(x[,2])) + var(f3(x[,3])) + var(f4(x[,4])) + var(f5(x[,5]))
sd = sqrt(V_sig / (p-5) / SNR)
print(sd)
x_nois = pnorm(matrix(rnorm(n * (p-5), 0, sd), n, (p-5)))
# x_nois = matrix(runif(n * (p-5)), n, (p-5))
x = cbind(x, x_nois)
# Set the outer margins
# par(oma = c(0, 0, 0, 0))
# Set the inner margin
# par(mar = c(4, 4, 3, 1))
# par(mfrow = c(1,5))
# plot(x[,1], f1(x[,1]), cex = .6, pch = 16, xlab = 'x1', ylab = 'f1')
# plot(x[,2], f2(x[,2]), cex = .6, pch = 16, xlab = 'x2', ylab = 'f2')
# plot(x[,3], f3(x[,3]), cex = .6, pch = 16, xlab = 'x3', ylab = 'f3')
# plot(x[,4], f4(x[,4]), cex = .6, pch = 16, xlab = 'x4', ylab = 'f4')
# plot(x[,5], f5(x[,5]), cex = .6, pch = 16, xlab = 'x5', ylab = 'f5')
# par(mfrow = c(1,1))
if(response == "regression"){
# SNR = sqrt(.6*(p-5)) # SNR = 4일 때
# print(SNR)
# f = f + rnorm(n, 0, SNR)
# f = f
out = list(x = x, y = f)
}
if(response == "classification"){
# SNR = sqrt(var(f) / 4)
# SNR = sqrt(.6*(p-5)) # SNR = 4일 때
# e = rnorm(n, 0, SNR)
prob = exp(f)/(exp(f) + 1)
y = rbinom(n, 1, prob)
# plot(prob)
# print(table(y))
out = list(x = x, f = f, y = y)
}
if(response == "count"){
mu = exp(f/sqrt(2)/p)
# SNR = sqrt(var(f) / 4)
# SNR = sqrt(.6*(p-5))
# e = rnorm(n, 0, SNR)
# mu = exp(f)
y = rpois(n, mu)
out = list(x = x, f = f, y = y)
}
if(response == 'survival'){
# Sigma = matrix(1, 8, 8)
# for(j in 1:8){
#   for(k in 1:8){
#     Sigma[j, k] = rho^abs(j-k)
#   }
# }
#
# x_sig = rtmvnorm(n, mean = rep(0, 8), sigma = Sigma, lower = rep(-2, 8), upper = rep(2, 8))
# x_nois = rtmvnorm(n, mean = rep(0, p-8), sigma = diag(1, p-8, p-8), lower = rep(-2, p-8), upper = rep(2, p-8))
# x = cbind(x_sig, x_nois)
# x = apply(x, 2, rescale)
# Sigma = matrix(1, 5, 5)
# for(j in 1:5){
#   for(k in 1:5){
#     Sigma[j, k] = rho^abs(j-k)
#   }
# }
#
# x_sig = rtmvnorm(n, mean = rep(0, 5), sigma = Sigma, lower = rep(-2, 5), upper = rep(2, 5))
# x_nois = rtmvnorm(n, mean = rep(0, p-5), sigma = diag(1, p-5, p-5), lower = rep(-2, p-5), upper = rep(2, p-5))
# x = cbind(x_sig, x_nois)
# x = apply(x, 2, rescale)
#
# f6 = function(t) cos(2 * pi * t) + sin(pi * t)
# f = 3 * (3 * x[, 1] - 2)^2 +  7 * cos((3 * x[, 3] - 1.5) * pi / 5) + ifelse(x[, 5] < 0.5, 0, 1) + 1 * f6(x[, 2]) + 11 * (exp(x[, 4]) - 3)
# f = 3 * (3 * x[, 1] - 2)^2 + 8 * cos((3 * x[, 3] - 1.5) * pi / 5) + ifelse(x[, 5] < 0.5, 0, 1) + 2 * f6(x[, 2]) + 11 * (exp(x[, 4]) - 2)
# f = 3 * (3 * x[, 1] - 2)^2 + 8 * cos((3 * x[, 3] - 1.5) * pi / 5) + 9 * (exp(x[, 5]) - 2) + 1 * f6(x[, 2]) + 5 * f4(x[, 4])
# SNR = sqrt(var(f) / 4)
# f = f + rnorm(n, 0, SNR)
surTime = rexp(n, exp(f))
cenTime = rexp(n, exp(-f) * runif(1, 4, 6))
y = cbind(time = apply(cbind(surTime, cenTime), 1, min), status = 1 * (surTime < cenTime))
# 14.003
# mean(tr_y[,"status"])
out = list(x = x, f = f, y = y)
}
return(out)
}
tr = data_generation(n, p, response = "classification")
tr_x = tr$x
tr_y = tr$y
table(tr_y)
#' This function uses the given test data to calculate predictions from the weights and biases generated by the model.
#'
#' @param n The number of observation of a example dataset.
#' @param p Dimension of a example dataset.
#' @param rho Correlation for first five significance variables.
#' @param SNR Signal-to-noise ratio.
#' @param response Type of response variable.
#'
#' @return a list containing the predicted value for the test data (f.new) and the transformed value of that predicted value (mu.new).
#' @export
data_generation = function(n, p, rho, SNR,
response = c("regression", "classification", "count", "survival", "interaction")){
f1 = function(t) t - 0.5
f2 = function(t) (2 * t - 1)^2 - 0.4
f3 = function(t) sin(2 * pi * t) / (2 - sin(pi * t))
f4 = function(t) 0.1*sin(2 * pi * t) + 0.2*cos(2 * pi * t) + 0.3*sin(2 * pi * t)^2 + 0.4*cos(2 * pi * t)^2 + 0.5*sin(2 * pi * t)^3 - 0.4
f5 = function(t) sin(pi * t^4) + t^4 - 0.4
# f1 = function(t) 5 * sin(3*t)
# f2 = function(t) -4 * t^4 + 9.33 * t^3 + 5 * t^2 - 8.33 * t
# f3 = function(t)  t * (1-t^2) * exp(3 * t) - 4
# f4 = function(t) 4 * t
# f5 = function(t) 4 * sin(-5 * log(sqrt(t+3)))
if(missing(response))
type = "classification"
response = match.arg(response)
if(missing(n)) n = 200
if(missing(p)) p = 10
if(missing(rho)) rho = 0.8
if(missing(SNR)) SNR = 2
if(p <= 5) stop("dimension size should be larger than 5.")
Sigma = matrix(rho, 5, 5)
diag(Sigma) = 1
# Sigma = matrix(1, 5, 5)
# for(j in 1:5){
#   for(k in 1:5){
#     Sigma[j, k] = rho^abs(j-k)
#   }
# }
x = pnorm(rmvnorm(n, sigma = Sigma))
# x = matrix(0, n, 5)
# x[, 1] = runif(n)
# U = runif(n)
# for(j in 2:5){
#   x[, j] = (runif(n) + 2 * U)/(1 + 2)
# }
f = 5 * f1(x[,1]) + 2 * f2(x[,2]) + 3 * f3(x[,3]) + 6 * f4(x[,4]) + 4 * f5(x[,5])
V_sig = var(5 * f1(x[,1])) + var(2 * f2(x[,2])) + var(3 * f3(x[,3])) + var(6 * f4(x[,4])) + var(4 * f5(x[,5]))
sd = sqrt(V_sig / (p-5) / SNR)
# f = f1(x[,1]) + f2(x[,2]) + f3(x[,3]) + f4(x[,4]) + f5(x[,5])
# V_sig = var(f1(x[,1])) + var(f2(x[,2])) + var(f3(x[,3])) + var(f4(x[,4])) + var(f5(x[,5]))
# sd = sqrt(V_sig / (p-5) / SNR)
print(sd)
x_nois = pnorm(matrix(rnorm(n * (p-5), 0, sd), n, (p-5)))
# x_nois = matrix(runif(n * (p-5)), n, (p-5))
x = cbind(x, x_nois)
# Set the outer margins
# par(oma = c(0, 0, 0, 0))
# Set the inner margin
# par(mar = c(4, 4, 3, 1))
# par(mfrow = c(1,5))
# plot(x[,1], f1(x[,1]), cex = .6, pch = 16, xlab = 'x1', ylab = 'f1')
# plot(x[,2], f2(x[,2]), cex = .6, pch = 16, xlab = 'x2', ylab = 'f2')
# plot(x[,3], f3(x[,3]), cex = .6, pch = 16, xlab = 'x3', ylab = 'f3')
# plot(x[,4], f4(x[,4]), cex = .6, pch = 16, xlab = 'x4', ylab = 'f4')
# plot(x[,5], f5(x[,5]), cex = .6, pch = 16, xlab = 'x5', ylab = 'f5')
# par(mfrow = c(1,1))
if(response == "regression"){
# SNR = sqrt(.6*(p-5)) # SNR = 4일 때
# print(SNR)
# f = f + rnorm(n, 0, SNR)
# f = f
out = list(x = x, y = f)
}
if(response == "classification"){
# SNR = sqrt(var(f) / 4)
# SNR = sqrt(.6*(p-5)) # SNR = 4일 때
# e = rnorm(n, 0, SNR)
prob = exp(f)/(exp(f) + 1)
y = rbinom(n, 1, prob)
# plot(prob)
# print(table(y))
out = list(x = x, f = f, y = y)
}
if(response == "count"){
mu = exp(f/sqrt(2)/p)
# SNR = sqrt(var(f) / 4)
# SNR = sqrt(.6*(p-5))
# e = rnorm(n, 0, SNR)
# mu = exp(f)
y = rpois(n, mu)
out = list(x = x, f = f, y = y)
}
if(response == 'survival'){
# Sigma = matrix(1, 8, 8)
# for(j in 1:8){
#   for(k in 1:8){
#     Sigma[j, k] = rho^abs(j-k)
#   }
# }
#
# x_sig = rtmvnorm(n, mean = rep(0, 8), sigma = Sigma, lower = rep(-2, 8), upper = rep(2, 8))
# x_nois = rtmvnorm(n, mean = rep(0, p-8), sigma = diag(1, p-8, p-8), lower = rep(-2, p-8), upper = rep(2, p-8))
# x = cbind(x_sig, x_nois)
# x = apply(x, 2, rescale)
# Sigma = matrix(1, 5, 5)
# for(j in 1:5){
#   for(k in 1:5){
#     Sigma[j, k] = rho^abs(j-k)
#   }
# }
#
# x_sig = rtmvnorm(n, mean = rep(0, 5), sigma = Sigma, lower = rep(-2, 5), upper = rep(2, 5))
# x_nois = rtmvnorm(n, mean = rep(0, p-5), sigma = diag(1, p-5, p-5), lower = rep(-2, p-5), upper = rep(2, p-5))
# x = cbind(x_sig, x_nois)
# x = apply(x, 2, rescale)
#
# f6 = function(t) cos(2 * pi * t) + sin(pi * t)
# f = 3 * (3 * x[, 1] - 2)^2 +  7 * cos((3 * x[, 3] - 1.5) * pi / 5) + ifelse(x[, 5] < 0.5, 0, 1) + 1 * f6(x[, 2]) + 11 * (exp(x[, 4]) - 3)
# f = 3 * (3 * x[, 1] - 2)^2 + 8 * cos((3 * x[, 3] - 1.5) * pi / 5) + ifelse(x[, 5] < 0.5, 0, 1) + 2 * f6(x[, 2]) + 11 * (exp(x[, 4]) - 2)
# f = 3 * (3 * x[, 1] - 2)^2 + 8 * cos((3 * x[, 3] - 1.5) * pi / 5) + 9 * (exp(x[, 5]) - 2) + 1 * f6(x[, 2]) + 5 * f4(x[, 4])
# SNR = sqrt(var(f) / 4)
# f = f + rnorm(n, 0, SNR)
surTime = rexp(n, exp(f))
cenTime = rexp(n, exp(-f) * runif(1, 4, 6))
y = cbind(time = apply(cbind(surTime, cenTime), 1, min), status = 1 * (surTime < cenTime))
# 14.003
# mean(tr_y[,"status"])
out = list(x = x, f = f, y = y)
}
return(out)
}
tr = data_generation(n, p, response = "classification")
tr_x = tr$x
tr_y = tr$y
table(tr_y)
train_test_split(tr_y, 0.7)
gaussian()$family
n=100
fsize <- floor(n/folds)
splits <- fsize * rep(1, folds)
folds=5
fsize <- floor(n/folds)
splits <- fsize * rep(1, folds)
nextra <- n - folds * fsize
nextra
splits
randid <- sample(1:n, n)
randid
# Separate indices for 0s and 1s
idx_0 <- which(y == 0)
y = tr_y
# Separate indices for 0s and 1s
idx_0 <- which(y == 0)
idx_1 <- which(y == 1)
n0 <- length(idx_0)
n1 <- length(idx_1)
# Compute fold sizes for each class
fsize_0 <- floor(n0 / folds)
fsize_1 <- floor(n1 / folds)
splits_0 <- fsize_0 * rep(1, folds)
splits_1 <- fsize_1 * rep(1, folds)
nextra_0 <- n0 - folds * fsize_0
nextra_1 <- n1 - folds * fsize_1
nextra_0
if (nextra_0 > 0) splits_0[1:nextra_0] <- splits_0[1:nextra_0] + 1
if (nextra_1 > 0) splits_1[1:nextra_1] <- splits_1[1:nextra_1] + 1
randid_0 <- sample(idx_0, n0)
randid_1 <- sample(idx_1, n1)
IDmat <- matrix(NA, ncol = folds, nrow = ceiling(n / folds))
# Assign 0s and 1s to folds
for (i in 1:folds) {
tempid_0 <- randid_0[(cumsum(splits_0)[i - 1] + 1):(cumsum(splits_0)[i])]
tempid_1 <- randid_1[(cumsum(splits_1)[i - 1] + 1):(cumsum(splits_1)[i])]
tempid <- c(tempid_0, tempid_1)
length(tempid) <- ceiling(n / folds)
IDmat[, i] <- tempid
}
folds
i
randid_0[(cumsum(splits_0)[i - 1] + 1):(cumsum(splits_0)[i])]
splits_0
splits_1
empid_1
tempid_1
randid_0
idx_0
n0
n1
matrix(NA, ncol = folds, nrow = ceiling(n / folds))
IDmat <- matrix(NA, ncol = folds, nrow = ceiling(n / folds))
randid_0
(cumsum(splits_0)[i - 1] + 1):(cumsum(splits_0)[i])
i
cumsum(splits_0)
(cumsum(splits_0)[i - 1] + 1)
splits_0
cumsum(splits_0)
[i - 1]
cumsum(splits_0)[i - 1]
i -
i - 1
i - 1
cumsum(splits_0)
cumsum(splits_0)[0]
cumsum(splits_0)[i]
randid_0[1:(cumsum(splits_0)[i])]
randid_1[1:(cumsum(splits_1)[i])]
cumsum(splits_1)[i]
tempid_0 <- randid_0[1:(cumsum(splits_0)[i])]
tempid_1 <- randid_1[1:(cumsum(splits_1)[i])]
c(tempid_0, tempid_1)
tempid <- c(tempid_0, tempid_1)
length(tempid) <- ceiling(n / folds)
IDmat[, i] <- tempid
IDmat
n
# Separate indices for 0s and 1s
idx_0 <- which(y == 0)
idx_1 <- which(y == 1)
n0 <- length(idx_0)
n1 <- length(idx_1)
# Compute fold sizes for each class
fsize_0 <- floor(n0 / folds)
fsize_1 <- floor(n1 / folds)
fsize_1
fsize_0
i=2
(cumsum(splits_0)[i] + 1)
randid_0
cumsum(splits_0)[i]
cumsum(splits_0)[i] + 1
cumsum(splits_0)[i]
cumsum(splits_0)[i - 1] + 1
(cumsum(splits_0)[i])
splits_0
randid_0[(cumsum(splits_0)[i - 1] + 1):(cumsum(splits_0)[i])]
randid_1[(cumsum(splits_1)[i - 1] + 1):(cumsum(splits_1)[i])]
tempid_0 <- randid_0[(cumsum(splits_0)[i - 1] + 1):(cumsum(splits_0)[i])]
tempid_1 <- randid_1[(cumsum(splits_1)[i - 1] + 1):(cumsum(splits_1)[i])]
tempid <- c(tempid_0, tempid_1)
length(tempid) <- ceiling(n / folds)
IDmat[, i] <- tempid
IDmat
IDmat <- matrix(NA, ncol = folds, nrow = ceiling(n / folds))
# Assign 0s and 1s to folds
for (i in 1:folds) {
if(i == 1){
tempid_0 <- randid_0[1:(cumsum(splits_0)[i])]
tempid_1 <- randid_1[1:(cumsum(splits_1)[i])]
} else{
tempid_0 <- randid_0[(cumsum(splits_0)[i - 1] + 1):(cumsum(splits_0)[i])]
tempid_1 <- randid_1[(cumsum(splits_1)[i - 1] + 1):(cumsum(splits_1)[i])]
}
tempid <- c(tempid_0, tempid_1)
length(tempid) <- ceiling(n / folds)
IDmat[, i] <- tempid
}
IDmat
randid_0
randid_1
is.na(IDmat)
sum(!is.na(IDmat))
cvsplitID = function (n, folds, family)
{
fsize <- floor(n/folds)
splits <- fsize * rep(1, folds)
nextra <- n - folds * fsize
if (nextra > 0) {
splits[1:nextra] <- splits[1:nextra] + 1
}
if(family != "binomial"){
randid <- sample(1:n, n)
IDmat <- matrix(NA, ncol = folds, nrow = ceiling(n/folds))
IDmat[, 1] <- randid[1:splits[1]]
for (i in 2:folds) {
tempid <- randid[(cumsum(splits)[i - 1] + 1):(cumsum(splits)[i])]
length(tempid) <- ceiling(n/folds)
IDmat[, i] <- tempid
}
}
if(family == "binomial"){
# Separate indices for 0s and 1s
idx_0 <- which(y == 0)
idx_1 <- which(y == 1)
n0 <- length(idx_0)
n1 <- length(idx_1)
# Compute fold sizes for each class
fsize_0 <- floor(n0 / folds)
fsize_1 <- floor(n1 / folds)
splits_0 <- fsize_0 * rep(1, folds)
splits_1 <- fsize_1 * rep(1, folds)
nextra_0 <- n0 - folds * fsize_0
nextra_1 <- n1 - folds * fsize_1
if (nextra_0 > 0) splits_0[1:nextra_0] <- splits_0[1:nextra_0] + 1
if (nextra_1 > 0) splits_1[1:nextra_1] <- splits_1[1:nextra_1] + 1
randid_0 <- sample(idx_0, n0)
randid_1 <- sample(idx_1, n1)
IDmat <- matrix(NA, ncol = folds, nrow = ceiling(n / folds))
# Assign 0s and 1s to folds
for (i in 1:folds) {
if(i == 1){
tempid_0 <- randid_0[1:(cumsum(splits_0)[i])]
tempid_1 <- randid_1[1:(cumsum(splits_1)[i])]
} else{
tempid_0 <- randid_0[(cumsum(splits_0)[i - 1] + 1):(cumsum(splits_0)[i])]
tempid_1 <- randid_1[(cumsum(splits_1)[i - 1] + 1):(cumsum(splits_1)[i])]
}
tempid <- c(tempid_0, tempid_1)
length(tempid) <- ceiling(n / folds)
IDmat[, i] <- tempid
}
}
return(IDmat)
}
remove.packages("cdcosso")
devtools::install_github("jiieunshin/cdcosso")
library(cdcosso)
library(tmvtnorm)
library(glmnet)
library(cosso)
n = 100
te_n = 1000
p_sig = 5
p = 200
out = matrix(0, 24, 13)
colnames(out) = c("n", "p", "gamma", "tp", "tp_se", "fp", "fp_se", "f1", "f1_se", "miss", "miss_se", "time", "time_se")
out = data.frame(out)
i=1
ll = 0
# for(nb in c(12, 25, 50, 100)){
iter = 50
ll = ll + 1
en3_signal_varsel = en1_signal_varsel = matrix(0, iter, p_sig)
time3 = time10 = c()
en3_varsel = en1_varsel = c()
en3_tp = en3_fp = en1_tp = en1_fp = en3_f1 = en1_f1 = en3_rec = en1_rec = en3_pre = en1_pre = c()
en3_miss = en1_miss = c()
en3_time = en1_time = c()
tr = data_generation(n, p, SNR = 5, response = "classification")
tr_x = tr$x
tr_y = tr$y
fit10 = try(cdcosso(tr_x, tr_y, family = 'binomial', gamma = 0.95, kernel = "spline", scale = F, algo = "CD"), silent = TRUE)
fit10
