if((iter == 1 & !conv1) | conv2){
cw.new = c.init / sqrt(w)
} else{
cw.new = cw
}
c.new = cw.new * sqrt(w)
b.new = sum((zw - Rw %*% cw.new) * sw) / sum(sw)
GH = calculate_GH_for_c(c.new, Rtheta, time, status, lambda0, Risk)
return(list(Gradient = GH$Gradient, Hessian = GH$Hessian, w.new = w, b.new = b.new, c.new = c.new, zw.new = zw, sw.new = sqrt(w), cw.new = cw.new))
}
# solve theta
getc_cvfit = cv.getc(x, time, status, rep(1, d)/wt^2, nfolds, lambda0, one.std, type, kparam, algo) ## 초기??? ??????. ????????? ??????
getc.cd = function(Rtheta, c.init, time, status, lambda0, Risk)
{
n = ncol(Rtheta)
wz = calculate_wz_for_c(c.init, Rtheta, lambda0, time, status, Risk)
w = wz$weight
z = wz$z
b = 0
rm(wz)
zw = z * sqrt(w)
Rw = Rtheta * w
# cw = c.init / sqrt(w)
sw = sqrt(w)
cw.new = rep(0, n)
cw = c.init
for(iter in 1:10){
for(j in 1:n){
# c.new[j] = sum((z - R[,-j] %*% c.old[-j]) * R[,j] * w) / (sum(w * R[,j]^2))
L = 2 * sum((zw - Rw[,-j] %*% cw[-j] - b * sw) * Rw[,j]) - n * lambda0 * c(Rw[j,-j] %*% cw[-j])
R = 2 * sum(Rw[,j]^2) + n * lambda0 * Rw[j,j]
cw.new[j] = L/R
loss = abs(cw - cw.new)
conv1 = max(loss) < 1e-6
conv2 = is.infinite(exp(cw.new[j] * sqrt(w[j])))
if((iter != 1 & conv1) | conv2) break
cw[j] = cw.new[j]
}
print(iter)
if((iter != 1 & conv1) | conv2) break
}
if((iter == 1 & !conv1) | conv2){
cw.new = c.init / sqrt(w)
} else{
cw.new = cw
}
c.new = cw.new * sqrt(w)
b.new = sum((zw - Rw %*% cw.new) * sw) / sum(sw)
GH = calculate_GH_for_c(c.new, Rtheta, time, status, lambda0, Risk)
return(list(Gradient = GH$Gradient, Hessian = GH$Hessian, w.new = w, b.new = b.new, c.new = c.new, zw.new = zw, sw.new = sqrt(w), cw.new = cw.new))
}
# solve theta
getc_cvfit = cv.getc(x, time, status, rep(1, d)/wt^2, nfolds, lambda0, one.std, type, kparam, algo) ## 초기??? ??????. ????????? ??????
getc.cd = function(Rtheta, c.init, time, status, lambda0, Risk)
{
n = ncol(Rtheta)
wz = calculate_wz_for_c(c.init, Rtheta, lambda0, time, status, Risk)
w = wz$weight
z = wz$z
b = 0
rm(wz)
zw = z * sqrt(w)
Rw = Rtheta * w
# cw = c.init / sqrt(w)
sw = sqrt(w)
cw.new = rep(0, n)
cw = c.init
iter = 0
while(iter <= 10){
iter = iter + 1
for(j in 1:n){
# c.new[j] = sum((z - R[,-j] %*% c.old[-j]) * R[,j] * w) / (sum(w * R[,j]^2))
L = 2 * sum((zw - Rw[,-j] %*% cw[-j] - b * sw) * Rw[,j]) - n * lambda0 * c(Rw[j,-j] %*% cw[-j])
R = 2 * sum(Rw[,j]^2) + n * lambda0 * Rw[j,j]
cw.new[j] = L/R
loss = abs(cw - cw.new)
conv1 = max(loss) < 1e-6
conv2 = is.infinite(exp(cw.new[j] * sqrt(w[j])))
if((iter != 1 & conv1) | conv2) break
cw[j] = cw.new[j]
}
if((iter != 1 & conv1) | conv2) break
}
if((iter == 1 & !conv1) | conv2){
cw.new = c.init / sqrt(w)
} else{
cw.new = cw
}
c.new = cw.new * sqrt(w)
b.new = sum((zw - Rw %*% cw.new) * sw) / sum(sw)
GH = calculate_GH_for_c(c.new, Rtheta, time, status, lambda0, Risk)
return(list(Gradient = GH$Gradient, Hessian = GH$Hessian, w.new = w, b.new = b.new, c.new = c.new, zw.new = zw, sw.new = sqrt(w), cw.new = cw.new))
}
# solve theta
getc_cvfit = cv.getc(x, time, status, rep(1, d)/wt^2, nfolds, lambda0, one.std, type, kparam, algo) ## 초기??? ??????. ????????? ??????
getc.cd = function(Rtheta, c.init, time, status, lambda0, Risk)
{
n = ncol(Rtheta)
wz = calculate_wz_for_c(c.init, Rtheta, lambda0, time, status, Risk)
w = wz$weight
z = wz$z
b = 0
rm(wz)
zw = z * sqrt(w)
Rw = Rtheta * w
# cw = c.init / sqrt(w)
sw = sqrt(w)
cw.new = rep(0, n)
cw = c.init
iter = 0
while(iter <= 10){
iter = iter + 1
for(j in 1:n){
# c.new[j] = sum((z - R[,-j] %*% c.old[-j]) * R[,j] * w) / (sum(w * R[,j]^2))
L = 2 * sum((zw - Rw[,-j] %*% cw[-j] - b * sw) * Rw[,j]) - n * lambda0 * c(Rw[j,-j] %*% cw[-j])
R = 2 * sum(Rw[,j]^2) + n * lambda0 * Rw[j,j]
cw.new[j] = L/R
loss = abs(cw - cw.new)
conv1 = max(loss) < 1e-6
conv2 = is.infinite(exp(cw.new[j] * sqrt(w[j])))
if((iter != 1 & conv1) | conv2) break
cw[j] = cw.new[j]
}
if((iter != 1 & conv1) | conv2) break
}
print(iter)
if((iter == 1 & !conv1) | conv2){
cw.new = c.init / sqrt(w)
} else{
cw.new = cw
}
c.new = cw.new * sqrt(w)
b.new = sum((zw - Rw %*% cw.new) * sw) / sum(sw)
GH = calculate_GH_for_c(c.new, Rtheta, time, status, lambda0, Risk)
return(list(Gradient = GH$Gradient, Hessian = GH$Hessian, w.new = w, b.new = b.new, c.new = c.new, zw.new = zw, sw.new = sqrt(w), cw.new = cw.new))
}
# solve theta
getc_cvfit = cv.getc(x, time, status, rep(1, d)/wt^2, nfolds, lambda0, one.std, type, kparam, algo) ## 초기??? ??????. ????????? ??????
getc.cd
getc.cd = function(Rtheta, c.init, time, status, lambda0, Risk)
{
n = ncol(Rtheta)
wz = calculate_wz_for_c(c.init, Rtheta, lambda0, time, status, Risk)
w = wz$weight
z = wz$z
b = 0
rm(wz)
zw = z * sqrt(w)
Rw = Rtheta * w
# cw = c.init / sqrt(w)
sw = sqrt(w)
cw.new = rep(0, n)
cw = c.init
iter = 0
while(iter <= 10){
iter = iter + 1
for(j in 1:n){
# c.new[j] = sum((z - R[,-j] %*% c.old[-j]) * R[,j] * w) / (sum(w * R[,j]^2))
L = 2 * sum((zw - Rw[,-j] %*% cw[-j] - b * sw) * Rw[,j]) - n * lambda0 * c(Rw[j,-j] %*% cw[-j])
R = 2 * sum(Rw[,j]^2) + n * lambda0 * Rw[j,j]
cw.new[j] = L/R
loss = abs(cw - cw.new)
conv1 = max(loss) < 1e-6
conv2 = is.infinite(exp(cw.new[j] * sqrt(w[j])))
if((iter != 1 & conv1) | conv2) break
cw[j] = cw.new[j]
}
if((iter != 1 & conv1) | conv2) break
}
print(iter)
if((iter == 1 & !conv1) | conv2){
cw.new = c.init / sqrt(w)
} else{
cw.new = cw
}
c.new = cw.new * sqrt(w)
b.new = sum((zw - Rw %*% cw.new) * sw) / sum(sw)
GH = calculate_GH_for_c(c.new, Rtheta, time, status, lambda0, Risk)
return(list(Gradient = GH$Gradient, Hessian = GH$Hessian, w.new = w, b.new = b.new, c.new = c.new, zw.new = zw, sw.new = sqrt(w), cw.new = cw.new))
}
getc.cd
# solve theta
getc_cvfit = cv.getc(x, time, status, rep(1, d)/wt^2, nfolds, lambda0, one.std, type, kparam, algo) ## 초기??? ??????. ????????? ??????
getc.cd = function(Rtheta, c.init, time, status, lambda0, Risk)
{
n = ncol(Rtheta)
wz = calculate_wz_for_c(c.init, Rtheta, lambda0, time, status, Risk)
w = wz$weight
z = wz$z
b = 0
rm(wz)
zw = z * sqrt(w)
Rw = Rtheta * w
# cw = c.init / sqrt(w)
sw = sqrt(w)
cw.new = rep(0, n)
cw = c.init
iter = 0
while(iter <= 10){
iter = iter + 1
for(j in 1:n){
# c.new[j] = sum((z - R[,-j] %*% c.old[-j]) * R[,j] * w) / (sum(w * R[,j]^2))
L = 2 * sum((zw - Rw[,-j] %*% cw[-j] - b * sw) * Rw[,j]) - n * lambda0 * c(Rw[j,-j] %*% cw[-j])
R = 2 * sum(Rw[,j]^2) + n * lambda0 * Rw[j,j]
cw.new[j] = L/R
loss = abs(cw - cw.new)
conv1 = max(loss) < 1e-6
conv2 = is.infinite(exp(cw.new[j] * sqrt(w[j])))
if((iter != 1 & conv1) | conv2) break
cw[j] = cw.new[j]
}
if((iter != 1 & conv1) | conv2) break
}
print(iter)
print(conv1)
print(conv2)
if((iter == 1 & !conv1) | conv2){
cw.new = c.init / sqrt(w)
} else{
cw.new = cw
}
c.new = cw.new * sqrt(w)
b.new = sum((zw - Rw %*% cw.new) * sw) / sum(sw)
GH = calculate_GH_for_c(c.new, Rtheta, time, status, lambda0, Risk)
return(list(Gradient = GH$Gradient, Hessian = GH$Hessian, w.new = w, b.new = b.new, c.new = c.new, zw.new = zw, sw.new = sqrt(w), cw.new = cw.new))
}
# solve theta
getc_cvfit = cv.getc(x, time, status, rep(1, d)/wt^2, nfolds, lambda0, one.std, type, kparam, algo) ## 초기??? ??????. ????????? ??????
getc.cd = function(Rtheta, c.init, time, status, lambda0, Risk)
{
n = ncol(Rtheta)
wz = calculate_wz_for_c(c.init, Rtheta, lambda0, time, status, Risk)
w = wz$weight
z = wz$z
b = 0
rm(wz)
zw = z * sqrt(w)
Rw = Rtheta * w
# cw = c.init / sqrt(w)
sw = sqrt(w)
cw.new = rep(0, n)
cw = c.init
iter = 0
while(iter <= 10){
iter = iter + 1
for(j in 1:n){
# c.new[j] = sum((z - R[,-j] %*% c.old[-j]) * R[,j] * w) / (sum(w * R[,j]^2))
L = 2 * sum((zw - Rw[,-j] %*% cw[-j] - b * sw) * Rw[,j]) - n * lambda0 * c(Rw[j,-j] %*% cw[-j])
R = 2 * sum(Rw[,j]^2) + n * lambda0 * Rw[j,j]
cw.new[j] = L/R
loss = abs(cw - cw.new)
conv1 = max(loss) < 1e-6
conv2 = is.infinite(exp(cw.new[j] * sqrt(w[j])))
if((iter != 1 & conv1) | conv2) break
cw[j] = cw.new[j]
}
if((iter != 1 & conv1) | conv2) break
}
print(conv1)
print(conv2)
print(iter)
if((iter == 1 & !conv1) | conv2){
cw.new = c.init / sqrt(w)
} else{
cw.new = cw
}
c.new = cw.new * sqrt(w)
b.new = sum((zw - Rw %*% cw.new) * sw) / sum(sw)
GH = calculate_GH_for_c(c.new, Rtheta, time, status, lambda0, Risk)
return(list(Gradient = GH$Gradient, Hessian = GH$Hessian, w.new = w, b.new = b.new, c.new = c.new, zw.new = zw, sw.new = sqrt(w), cw.new = cw.new))
}
# solve theta
getc_cvfit = cv.getc(x, time, status, rep(1, d)/wt^2, nfolds, lambda0, one.std, type, kparam, algo) ## 초기??? ??????. ????????? ??????
getc.cd = function(Rtheta, c.init, time, status, lambda0, Risk)
{
n = ncol(Rtheta)
wz = calculate_wz_for_c(c.init, Rtheta, lambda0, time, status, Risk)
w = wz$weight
z = wz$z
b = 0
rm(wz)
zw = z * sqrt(w)
Rw = Rtheta * w
# cw = c.init / sqrt(w)
sw = sqrt(w)
cw.new = rep(0, n)
cw = c.init
iter = 0
while(iter <= 10){
iter = iter + 1
for(j in 1:n){
# c.new[j] = sum((z - R[,-j] %*% c.old[-j]) * R[,j] * w) / (sum(w * R[,j]^2))
L = 2 * sum((zw - Rw[,-j] %*% cw[-j] - b * sw) * Rw[,j]) - n * lambda0 * c(Rw[j,-j] %*% cw[-j])
R = 2 * sum(Rw[,j]^2) + n * lambda0 * Rw[j,j]
cw.new[j] = L/R
print(cw.new)
loss = abs(cw - cw.new)
conv1 = max(loss) < 1e-6
conv2 = is.infinite(exp(cw.new[j] * sqrt(w[j])))
if((iter != 1 & conv1) | conv2) break
cw[j] = cw.new[j]
}
if((iter != 1 & conv1) | conv2) break
}
if((iter == 1 & !conv1) | conv2){
cw.new = c.init / sqrt(w)
} else{
cw.new = cw
}
c.new = cw.new * sqrt(w)
b.new = sum((zw - Rw %*% cw.new) * sw) / sum(sw)
GH = calculate_GH_for_c(c.new, Rtheta, time, status, lambda0, Risk)
return(list(Gradient = GH$Gradient, Hessian = GH$Hessian, w.new = w, b.new = b.new, c.new = c.new, zw.new = zw, sw.new = sqrt(w), cw.new = cw.new))
}
# solve theta
getc_cvfit = cv.getc(x, time, status, rep(1, d)/wt^2, nfolds, lambda0, one.std, type, kparam, algo) ## 초기??? ??????. ????????? ??????
getc.cd = function(Rtheta, c.init, time, status, lambda0, Risk)
{
n = ncol(Rtheta)
wz = calculate_wz_for_c(c.init, Rtheta, lambda0, time, status, Risk)
w = wz$weight
z = wz$z
b = 0
rm(wz)
zw = z * sqrt(w)
Rw = Rtheta * w
# cw = c.init / sqrt(w)
sw = sqrt(w)
cw.new = rep(NA, n)
cw = rep(0, n)
iter = 0
while(iter <= 10){
iter = iter + 1
for(j in 1:n){
# c.new[j] = sum((z - R[,-j] %*% c.old[-j]) * R[,j] * w) / (sum(w * R[,j]^2))
L = 2 * sum((zw - Rw[,-j] %*% cw[-j] - b * sw) * Rw[,j]) - n * lambda0 * c(Rw[j,-j] %*% cw[-j])
R = 2 * sum(Rw[,j]^2) + n * lambda0 * Rw[j,j]
cw.new[j] = L/R
loss = abs(cw - cw.new)
conv1 = max(loss) < 1e-6
conv2 = is.infinite(exp(cw.new[j] * sqrt(w[j])))
if((iter != 1 & conv1) | conv2) break
cw[j] = cw.new[j]
}
if((iter != 1 & conv1) | conv2) break
}
if((iter == 1 & !conv1) | conv2){
cw.new = c.init / sqrt(w)
} else{
cw.new = cw
}
c.new = cw.new * sqrt(w)
b.new = sum((zw - Rw %*% cw.new) * sw) / sum(sw)
GH = calculate_GH_for_c(c.new, Rtheta, time, status, lambda0, Risk)
return(list(Gradient = GH$Gradient, Hessian = GH$Hessian, w.new = w, b.new = b.new, c.new = c.new, zw.new = zw, sw.new = sqrt(w), cw.new = cw.new))
}
# solve theta
getc_cvfit = cv.getc(x, time, status, rep(1, d)/wt^2, nfolds, lambda0, one.std, type, kparam, algo) ## 초기??? ??????. ????????? ??????
getc.cd = function(Rtheta, c.init, time, status, lambda0, Risk)
{
n = ncol(Rtheta)
wz = calculate_wz_for_c(c.init, Rtheta, lambda0, time, status, Risk)
w = wz$weight
z = wz$z
b = 0
rm(wz)
zw = z * sqrt(w)
Rw = Rtheta * w
# cw = c.init / sqrt(w)
sw = sqrt(w)
cw.new = rep(NA, n)
cw = rep(0, n)
iter = 0
while(iter <= 10){
iter = iter + 1
for(j in 1:n){
# c.new[j] = sum((z - R[,-j] %*% c.old[-j]) * R[,j] * w) / (sum(w * R[,j]^2))
L = 2 * sum((zw - Rw[,-j] %*% cw[-j] - b * sw) * Rw[,j]) - n * lambda0 * c(Rw[j,-j] %*% cw[-j])
R = 2 * sum(Rw[,j]^2) + n * lambda0 * Rw[j,j]
cw.new[j] = L/R
print(cw.new)
loss = abs(cw - cw.new)
conv1 = max(loss) < 1e-6
conv2 = is.infinite(exp(cw.new[j] * sqrt(w[j])))
if((iter != 1 & conv1) | conv2) break
cw[j] = cw.new[j]
}
if((iter != 1 & conv1) | conv2) break
}
if((iter == 1 & !conv1) | conv2){
cw.new = c.init / sqrt(w)
} else{
cw.new = cw
}
c.new = cw.new * sqrt(w)
b.new = sum((zw - Rw %*% cw.new) * sw) / sum(sw)
GH = calculate_GH_for_c(c.new, Rtheta, time, status, lambda0, Risk)
return(list(Gradient = GH$Gradient, Hessian = GH$Hessian, w.new = w, b.new = b.new, c.new = c.new, zw.new = zw, sw.new = sqrt(w), cw.new = cw.new))
}
# solve theta
getc_cvfit = cv.getc(x, time, status, rep(1, d)/wt^2, nfolds, lambda0, one.std, type, kparam, algo) ## 초기??? ??????. ????????? ??????
getc.cd = function(Rtheta, c.init, time, status, lambda0, Risk)
{
n = ncol(Rtheta)
wz = calculate_wz_for_c(c.init, Rtheta, lambda0, time, status, Risk)
w = wz$weight
z = wz$z
b = 0
rm(wz)
zw = z * sqrt(w)
Rw = Rtheta * w
# cw = c.init / sqrt(w)
sw = sqrt(w)
cw.new = rep(0, n)
cw = c.init
iter = 0
while(iter <= 10){
iter = iter + 1
for(j in 1:n){
# c.new[j] = sum((z - R[,-j] %*% c.old[-j]) * R[,j] * w) / (sum(w * R[,j]^2))
L = 2 * sum((zw - Rw[,-j] %*% cw[-j] - b * sw) * Rw[,j]) - n * lambda0 * c(Rw[j,-j] %*% cw[-j])
R = 2 * sum(Rw[,j]^2) + n * lambda0 * Rw[j,j]
cw.new[j] = L/R
loss = abs(cw - cw.new)
conv1 = max(loss) < 1e-6
conv2 = is.infinite(exp(cw.new[j] * sqrt(w[j])))
if((iter != 1 & conv1) | conv2) break
cw[j] = cw.new[j]
}
if((iter != 1 & conv1) | conv2) break
}
if((iter == 1 & !conv1) | conv2){
cw.new = c.init / sqrt(w)
} else{
cw.new = cw
}
c.new = cw.new * sqrt(w)
b.new = sum((zw - Rw %*% cw.new) * sw) / sum(sw)
GH = calculate_GH_for_c(c.new, Rtheta, time, status, lambda0, Risk)
return(list(Gradient = GH$Gradient, Hessian = GH$Hessian, w.new = w, b.new = b.new, c.new = c.new, zw.new = zw, sw.new = sqrt(w), cw.new = cw.new))
}
time = unlist(y[, 'time'])
status = unlist(y[, 'status'])
mscale = rep(1, d)/wt^2
nfolds = 5
cand.lambda = lambda0
n <- length(time)
IDmat <- cvsplitID(n, nfolds)
K = make_anovaKernel(x, x, type = type, kparam)
d = K$numK
R = array(NA, c(n, n, d))
for(j in 1:d){
R[, , j] = K$K[[j]]
}
Rtheta <- wsGram(R, mscale)
RS = RiskSet(time, status)
measure <- matrix(NA, ncol = length(cand.lambda), nrow = nfolds)
f=k=1
testID <- IDmat[!is.na(IDmat[, f]), f]
trainID <- (1:n)[-testID]
# generate SS-ANOVA
tr_n = length(trainID)
te_n = length(testID)
tr_RS = RiskSet(time[trainID], status[trainID])
te_RS = RiskSet(time[testID], status[testID])
tr_R = array(NA, c(tr_n, tr_n, d))
te_R = array(NA, c(te_n, tr_n, d))
for(j in 1:d){
tr_R[, , j] = K$K[[j]][trainID, trainID]
te_R[, , j] = K$K[[j]][testID, trainID]
}
tr_Rtheta <- wsGram(tr_R, mscale)
te_Rtheta <- wsGram(te_R, mscale)
c.init = as.vector(glmnet(tr_Rtheta, cbind(time = time[trainID], status = status[trainID]), family = 'cox', lambda = cand.lambda[k], alpha = 0)$beta)
c.init
measure <- matrix(NA, ncol = length(cand.lambda), nrow = nfolds)
for (f in 1:nfolds) {
testID <- IDmat[!is.na(IDmat[, f]), f]
trainID <- (1:n)[-testID]
# generate SS-ANOVA
tr_n = length(trainID)
te_n = length(testID)
tr_RS = RiskSet(time[trainID], status[trainID])
te_RS = RiskSet(time[testID], status[testID])
tr_R = array(NA, c(tr_n, tr_n, d))
te_R = array(NA, c(te_n, tr_n, d))
for(j in 1:d){
tr_R[, , j] = K$K[[j]][trainID, trainID]
te_R[, , j] = K$K[[j]][testID, trainID]
}
tr_Rtheta <- wsGram(tr_R, mscale)
te_Rtheta <- wsGram(te_R, mscale)
for (k in 1:length(cand.lambda)) {
# dyn.load("src/coxfuncs.dll")
# .Call("Cget_c", tr_Rtheta, Rtheta, n, tr_n, tr_RS, c.init, cand.lambda[k])
if(algo == "CD"){
c.init = as.vector(glmnet(tr_Rtheta, cbind(time = time[trainID], status = status[trainID]), family = 'cox', lambda = cand.lambda[k], alpha = 0)$beta)
fit = getc.cd(tr_Rtheta, c.init, time[trainID], status[trainID], cand.lambda[k], tr_RS)
}
if(algo == "QP"){
# fit = getc.QP(tr_Rtheta, Rtheta, time[trainID], status[trainID], tr_RS, cand.lambda[k])
}
Lik = PartialLik(time[testID], status[testID], te_RS, te_Rtheta %*% fit$c.new)
UHU = fit$Hessian %*% fit$c.new - fit$Gradient / diag(fit$Hessian)
measure[f, k] = Lik + sum(status[testID] == 1)/te_n^2 * (sum(diag(UHU))/(tr_n -  1) - sum(UHU)/(tr_n^2 - tr_n))
}
}
measure
# solve theta
getc_cvfit = cv.getc(x, time, status, rep(1, d)/wt^2, nfolds, lambda0, one.std, type, kparam, algo) ## 초기??? ??????. ????????? ??????
getc_cvfit
optlambda0 = getc_cvfit$optlambda
