kernelCoord[[index]] = paste("x", d, sep = "")
}
for (i in 1:(dimx - 1)) {
for (j in (i + 1):dimx) {
index = index + 1
A = anova_kernel[[i]]
B = anova_kernel[[j]]
anova_kernel[[index]] = A * B
kernelCoord[[index]] = paste("x", i, " x", j, sep = "")
}
}
} else if (type == "gaussian2") {
numK = dimx + dimx * (dimx - 1) / 2
anova_kernel = vector(mode = "list", numK)
kernelCoord = vector(mode = "list", numK)
index = 0
for (d in 1:dimx) {
index = index + 1
A = x[, d, drop = FALSE]
B = y[, d, drop = FALSE]
anova_kernel[[index]] = kernelMatrix(A, B, type, kparam)
kernelCoord[[index]] = paste("x", d, sep = "")
}
for (i in 1:(dimx - 1)) {
for (j in (i + 1):dimx) {
index = index + 1
A = anova_kernel[[i]]
B = anova_kernel[[j]]
anova_kernel[[index]] = A * B
kernelCoord[[index]] = paste("x", i, " x", j, sep = "")
}
}
} else { # calculate anova kernels for main effects
numK = dimx
anova_kernel = vector(mode = "list", numK)
kernelCoord = vector(mode = "list", numK)
for (d in 1:dimx) {
A = x[, d, drop = FALSE]
B = y[, d, drop = FALSE]
anova_kernel[[d]] = kernelMatrix(A, B, type, kparam)
kernelCoord[[d]] = paste("x", d, sep = "")
}
}
return(list(x = x, K = anova_kernel, coord = kernelCoord, numK = numK, kernel = type, kparam = kparam))
}
rescale = function (x)
{
if (length(unique(x)) > 6)
return((x - min(x))/(max(x) - min(x)))
else return(x)
}
combine_kernel = function (Gramat, mscale)
{
n1 <- dim(Gramat)[1]
n2 <- dim(Gramat)[2]
d <- dim(Gramat)[3]
KK <- matrix(0, n1, n2)
for (j in 1:d) KK = KK + mscale[j] * Gramat[, , j]
return(KK)
}
rescale_theta = function (x)
{
d = length(x)
if(sum(x == 0) == d) x = rep(1e-10, d)
return(x)
}
cvsplitID = function (n, folds)
{
fsize <- floor(n/folds)
splits <- fsize * rep(1, folds)
nextra <- n - folds * fsize
if (nextra > 0) {
splits[1:nextra] <- splits[1:nextra] + 1
}
randid <- sample(1:n, n)
IDmat <- matrix(NA, ncol = folds, nrow = ceiling(n/folds))
IDmat[, 1] <- randid[1:splits[1]]
for (i in 2:folds) {
tempid <- randid[(cumsum(splits)[i - 1] + 1):(cumsum(splits)[i])]
length(tempid) <- ceiling(n/folds)
IDmat[, i] <- tempid
}
return(IDmat)
}
# y = tr_y
# family = 'Cox'
# gamma = 0.8
# type = "spline"
# one.std = TRUE
# scale = T
# wt = rep(1, ncol(x))
# kparam = 1
# nfolds =5
# algo = "QP"
cdcosso = function (x,
y,
family = c("gaussian", "binomial", "poisson", "Cox"),
kernel = c("linear", "gaussian", "poly", "spline"),
effect = c("main", "interaction"),
algo = c("CD", "QP"),
kparam = 1,
lambda0 = exp(seq(log(2^{-11}), log(2^{2}), length.out = 20)),
lambda_theta = exp(seq(log(2^{-11}), log(2^{2}), length.out = 20)),
gamma = 0.95, scale = TRUE)
{
n = nrow(x)
colnames(x) = NULL
rownames(x) = NULL
if(class(x)[1] != "data.frame")
stop("A input x must be dataframe.")
# family
family = match.arg(family)
if(family == "gaussian")
obj = gaussian()
if(family == "binomial")
obj =  binomial()
if(family == "poisson")
obj = poisson()
if(missing(kernel))
type = 'spline'
else
type = match.arg(kernel)
if(missing(algo))
algo = "CD"
if(missing(effect))
effect = 'main'
else
effect = match.arg(kernel)
if(effect == "interaction") kernel = paste0(kernel, "2")
# if(missing(lambda0))
#   lambda0 = exp(seq(log(2^{-11}), log(2^{2}), length.out = 20))
#
# if(missing(lambda_theta))
#   lambda_theta = exp(seq(log(2^{-11}), log(2^{2}), length.out = 20))
if (family == "Cox" & !all(match(c("time", "status"), dimnames(y)[[2]], 0))) {
stop("Cox model requires a matrix with columns 'time' and 'status' as a response")
}
objnm = ifelse(family == 'gaussian' | family == 'binomial' | family == 'poisson', 'glm', family)
wt = rep(1, ncol(x))
# fitting
out = switch(objnm,
glm = cdcosso.glm(x, y, wt, lambda0, lambda_theta, gamma, obj, type, kparam, scale, algo),
Cox = cdcosso.cox(x, unlist(y[, "time"]), unlist(y[, "status"]), wt, lambda0, lambda_theta, gamma, type, kparam, scale, algo)
# Negbin, svm ì¶”???
)
attr(out, "class") = "cdcosso"
return(out)
}
RiskSet = function (time, status)
{
uniqTime = sort(unique(time[status == 1]))
RiskSet = matrix(0, ncol = length(uniqTime), nrow = length(time))
for (k in 1:length(uniqTime)) {
risk.id = which(time >= uniqTime[k])
RiskSet[risk.id, k] = risk.id
}
return(RiskSet)
}
# mscale = wt
# cand.lambda = lambda0
cv.getc = function(K, time, status, mscale, cand.lambda, type, kparam, algo, show)
{
d = K$numK
n <- length(time)
len = length(cand.lambda)
R = array(NA, c(n, n, d))
for(j in 1:d){
R[, , j] = K$K[[j]]
}
Rtheta <- combine_kernel(R, mscale)
f.init = rep(0.5, n)
RS = RiskSet(time, status)
measure <- rep(0, length(cand.lambda))
for (k in 1:length(cand.lambda)){
if(algo == "CD"){
c.init = as.vector(glmnet(Rtheta, cbind(time = time, status = status), family = 'cox',
lambda = cand.lambda[k], alpha = 0, standardize = FALSE)$beta)
fit = getc.cd(Rtheta, f.init, c.init, time, status, cand.lambda[k], RS)
Rw = Rtheta * fit$w.new
XX = fit$zw.new - Rw %*% fit$cw.new - fit$b.new * sqrt(fit$w.new)
num = t(XX) %*% XX + 1
S = Rw %*% ginv(t(Rw) %*% Rw) %*% t(Rw)
den = (1 - sum(diag(S)) / n)^2 + 1
measure[k] <- as.vector( num / den / n )
# W = outer(fit$gradient, fit$gradient)
# UHU = Rtheta %*% W %*% t(Rtheta)
# measure[k] <- cosso::PartialLik(time, status, RS, Rtheta %*% fit$c.new)
# + sum(status == 1)/n^2 * (sum(diag(UHU))/(n - 1) - sum(UHU)/(n^2 - n))
}
if(algo == "QP"){
c.init = as.vector(glmnet(Rtheta, cbind(time = time, status = status), family = 'cox',
lambda = cand.lambda[k], alpha = 0, standardize = FALSE)$beta)
fit = getc.QP(R, Rtheta, c.init, time, status, mscale, cand.lambda[k], RS)
measure[k] <- cosso::PartialLik(time, status, RS, Rtheta %*% fit$c.new) + sum(status == 1)/n^2 * (sum(diag(fit$UHU))/(n - 1) - sum(fit$UHU)/(n^2 - n))
# HH =  fit$H - 2 * cand.lambda[k] * Rtheta
# HHH = ginv(HH/cand.lambda[k] + Rtheta)
# GG = fit$G - 2 * cand.lambda[k] * Rtheta %*% fit$c.new
#
# z = (HHH %*% fit$c.new - GG) / cand.lambda[k]
# num = t(z - Rtheta %*% fit$c.new) %*% ginv(HH) %*% (z - Rtheta %*% fit$c.new)
# S = Rtheta %*% ginv(Rtheta + HH/cand.lambda[k])
# den = (1 - sum(diag(S)) / n)^2 + 1
# measure[k] <- as.vector( num / den / n )
}
}
id = which.min(measure)[1]
optlambda = cand.lambda[id]
# optimal lambda1
if(show) plot(log(cand.lambda), measure, main = "Cox family", xlab = expression("Log(" * lambda[0] * ")"), ylab = "partial likelihood", ylim = range(measure), pch = 15, col = 'red')
if(algo == "CD"){
c.init = as.vector(glmnet(Rtheta, cbind(time = time, status = status), family = 'cox',
lambda = optlambda, alpha = 0, standardize = FALSE)$beta)
fit = getc.cd(Rtheta, f.init, c.init, time, status, optlambda, RS)
out = list(measure = measure, R = R, f.new = c(Rtheta %*% fit$c.new) + fit$b.new, zw.new = fit$zw.new, w.new = fit$w.new,
b.new = fit$b.new, cw.new = fit$cw.new, c.new = fit$c.new, optlambda = optlambda, conv = TRUE)
}
if(algo == "QP"){
c.init = as.vector(glmnet(Rtheta, cbind(time = time, status = status), family = 'cox',
lambda = optlambda, alpha = 0, standardize = FALSE)$beta)
fit = getc.QP(R, Rtheta, c.init, time, status, mscale, optlambda, RS)
z.new = (fit$H %*% fit$c.new - fit$G)/optlambda
W.new = ginv(fit$H)
w.new = 1/diag(fit$H)
zw.new = z.new * sqrt(w.new)
cw.new = fit$c.new / sqrt(w.new)
b.new = sum((zw.new - Rtheta %*% cw.new) * sqrt(w.new)) / sum(w.new)
out = list(measure = measure, R = R, f.new = Rtheta %*% fit$c.new + fit$b.new, W.new = W.new, w.new = w.new, zw.new = zw.new, cw.new = cw.new, c.new = fit$c.new, b.new = b.new,
optlambda = optlambda, conv = TRUE)
}
rm(K)
rm(Rtheta)
return(out)
}
getc.cd = function(Rtheta, f, c.init, time, status, lambda0, Risk)
{
n = ncol(Rtheta)
# wz = calculate_wz_for_c(c.init, Rtheta, time, status, Risk)
# w = wz$weight
# z = wz$z
b = 0
y = cbind(time = time, status = status)
coxgrad_results = coxgrad(f, y, rep(1, length(f)), std.weights = FALSE, diag.hessian = TRUE)
w = -attributes(coxgrad_results)$diag_hessian
z = (f - b) - ifelse(w != 0, -coxgrad_results/w, 0)
zw = z * sqrt(w)
Rw = Rtheta * w
cw = c.init
cw.new = temp = c.init / sqrt(w)
sw = sqrt(w)
fit = .Call("c_step", zw, Rw, cw, sw, n, lambda0, PACKAGE = "cdcosso")
b.new = fit$b.new
c.new = fit$c.new
cw.new = fit$cw.new
return(list(zw.new = zw, w.new = w, sw.new = sw, b.new = b.new, c.new = c.new, cw.new = cw.new))
}
getc.QP = function (R, Rtheta, c.init, time, status, mscale, lambda0, RS)
{
n = length(time)
p = length(mscale)
GH = cosso::gradient.Hessian.C(c.init, R, R, time, status, mscale, lambda0, RS)
c.new = as.numeric(cosso::My_solve(GH$H, GH$H %*% c.init - GH$G))
UHU = Rtheta %*% cosso::My_solve(GH$H, t(Rtheta))
return(list(c.new = c.new, G = GH$G, H = GH$H, UHU = UHU))
}
calculate_wz_for_c = function(c.init, R, time, status, RS){
n = length(time)
Grad.Term = weight = z = rep(0, n)
for (k in 1:n) {
Sum.exp.eta.Grad = Sum.exp.eta.Hess = 0
id = which(RS[k,] > 0)
eta = as.numeric(R[k,] %*% c.init)
exp.eta = exp(eta)
for(r in id){
Sum.exp.eta = sum(exp(R[RS[,r],] %*% c.init))
Sum.exp.eta.Grad = Sum.exp.eta.Grad + exp.eta / Sum.exp.eta # {j in R_i} exp(R_j c)
Sum.exp.eta.Hess = Sum.exp.eta.Hess + ( exp.eta * Sum.exp.eta - exp.eta^2 ) / Sum.exp.eta^2
}
Grad.Term[k] = status[k] - Sum.exp.eta.Grad
weight[k] = Sum.exp.eta.Hess
z[k] = eta + (Grad.Term[k] + 0.1) / (weight[k] + 0.1)
}
return(list(z = z, gradient = Grad.Term, weight = weight))
}
# model = getc_cvfit
# lambda0 = getc_cvfit$optlambda
# mscale = wt
cv.gettheta = function (model, x, time, status, mscale, lambda0, lambda_theta, gamma, type, kparam, algo){
n = length(time)
d = length(mscale)
IDmat = model$IDmat
RS = RiskSet(time, status)
# solve theta
G <- matrix(0, nrow(model$R[, ,1]), d)
for (j in 1:d) {
G[, j] = model$R[, , j] %*% model$c.new * (mscale[j]^(-2))
}
if(algo == "QP") lambda_theta = exp(seq(log(1e-4), log(40), length.out = length(lambda_theta)))
len = length(lambda_theta)
measure <- rep(0, len)
save_theta <- list()
for (k in 1:len) {
if(algo == "CD"){
init.theta = rep(1, d)
# Gw = G * sqrt(model$w.new)
# uw = model$zw.new - model$b.new * sqrt(model$w.new) - (n/2) * lambda0 * model$cw.new
# theta.new = .Call("theta_step", Gw, uw, n, d, init.theta, lambda_theta[k], gamma)
# save_theta[[k]] <- theta.new
fit = gettheta.cd(init.theta, model$f.new, G, time, status, model$b.new, (n/2) * lambda0 * model$cw.new, lambda_theta[k], gamma, RS)
save_theta[[k]] <- fit$theta.new
theta.adj <- rescale_theta(fit$theta.new)
XX = fit$zw.new - fit$Gw %*% theta.adj
num = t(XX) %*% XX + 1
den = (1 - sum(diag( fit$Gw %*% ginv( t(fit$Gw) %*% fit$Gw) %*% t(fit$Gw) )) / n)^2 + 1
measure[k] <- as.vector(num / den / n)
# measure[k] <- cosso::PartialLik(time, status, RS, G %*% theta.adj)
}
if(algo == "QP"){
init.theta = rep(1, d)
fit = gettheta.QP(init.theta, model$c.new, G, time, status, lambda0, lambda_theta[k], RS)
save_theta[[k]] <- fit$theta.new
theta.adj <- rescale_theta(fit$theta.new)
measure[k] <- cosso::PartialLik(time, status, RS, G %*% theta.adj) + sum(status == 1)/n^2 * (sum(diag(fit$UHU))/(n - 1) - sum(fit$UHU)/(n^2 - n))
# measure[k] = cosso::PartialLik(time, status, RS, G %*% theta.adj) / (1 - sum(fit$theta.new != 0) / n)^2 / n
}
}
# print(save_theta)
id = which.min(measure)[1]
optlambda = lambda_theta[id]
# plotting error bar
xrange = log(lambda_theta)
plot(xrange, measure, main = "Cox family", xlab = expression("Log(" * lambda[theta] * ")"), ylab = "partial likelihood", ylim = range(measure), pch = 15, col = 'red')
if(algo == "CD"){
out = list(cv_error = measure, optlambda_theta = optlambda, gamma = gamma, theta.new = save_theta[[id]])
# fit = gettheta.cd(init.theta, G, time, status, model$b.new, (n/2) * lambda0 * model$cw.new, optlambda, gamma, RS)
# out = list(cv_error = measure, optlambda_theta = optlambda, gamma = gamma, theta.new = fit$theta.new)
}
if(algo == "QP"){
out = list(cv_error = measure, optlambda_theta = optlambda, gamma = gamma, theta.new = save_theta[[id]])
# fit = gettheta.QP(init.theta, model$c.new, G, time, status, lambda0, optlambda, RS)
# out = list(cv_error = measure, optlambda_theta = optlambda, gamma = gamma, theta.new = fit$theta.new)
}
return(out)
}
gettheta.cd = function(init.theta, f.init, G, time, status, bhat, const, lambda_theta, gamma, Risk){
n = nrow(G)
d = ncol(G)
r = lambda_theta * gamma * n
# wz = calculate_wz_for_theta(init.theta, G, time, status, Risk)
# w = wz$weight
# z = wz$z
f.init = rep(0.5, n)
y = cbind(time = time, status = status)
coxgrad_results = coxgrad(f.init, y, rep(1, nrow(G)), std.weights = FALSE, diag.hessian = TRUE)
w = - attributes(coxgrad_results)$diag_hessian
z = f.init - ifelse(w != 0, - coxgrad_results/w, 0)
uw = (z * sqrt(w)) - bhat * sqrt(w) - const
Gw = G * sqrt(w)
theta.new = .Call("theta_step", Gw, uw, n, d, init.theta, lambda_theta, gamma)
theta.new = ifelse(theta.new <= 1e-6, 0, theta.new)
return(list(Gw = Gw, z2.new = z * sqrt(w), w.new = w, theta.new = theta.new))
}
calculate_wz_for_theta = function(init.theta, G, time, status, RS){
n = length(time)
Grad.Term = weight = z = rep(0, n)
for (k in 1:n) {
Sum.exp.eta.Grad = Sum.exp.eta.Hess = 0
id = which(RS[k,] > 0)
eta = as.numeric(G[k,] %*% init.theta)
exp.eta = exp(eta)
for(r in id){
Sum.exp.eta = sum(exp(G[RS[,r],] %*% init.theta))
Sum.exp.eta.Grad = Sum.exp.eta.Grad + exp.eta / Sum.exp.eta # {j in R_i} exp(R_j c)
Sum.exp.eta.Hess = Sum.exp.eta.Hess + ( exp.eta * Sum.exp.eta - exp.eta^2 ) / Sum.exp.eta^2
}
Grad.Term[k] = status[k] - Sum.exp.eta.Grad
weight[k] = Sum.exp.eta.Hess
z[k] = eta + (Grad.Term[k] + 0.1) / (weight[k] + 0.1)
}
return(list(z = z, gradient = Grad.Term, weight = weight))
}
gettheta.QP = function(init.theta, c.hat, G, time, status, lambda0, lambda_theta, Risk){
n = nrow(G)
p = ncol(G)
Hess.FullNumer.unScale = array(NA, dim = c(length(init.theta),
length(init.theta),
n)
)
for (i in 1:n) Hess.FullNumer.unScale[, , i] = G[i, ] %*% t(G[i, ])
loop = 0
iter.diff = Inf
old.Theta = init.theta
while (loop < 15 & iter.diff > 1e-04) {
loop = loop + 1
GH = cosso::gradient.Hessian.Theta(old.Theta, c.hat, G, G,
lambda0, lambda_theta, time, status, Risk, Hess.FullNumer.unScale)
if(min(eigen(GH$H)$value) < 0)
GH$H = GH$H + max(1e-07, 1.5 * abs(min(eigen(GH$H)$value))) * diag(length(old.Theta))
dvec = -(GH$G - GH$H %*% old.Theta)
Amat = t(rbind(diag(p), rep(-1, p)))
bvec = c(rep(0, p), -lambda_theta)
new.Theta = cosso::My_solve.QP(GH$H, dvec, Amat, bvec)
new.Theta[new.Theta < 1e-07] = 0
iter.diff = mean(abs(new.Theta - old.Theta))
old.Theta = new.Theta
}
UHU = G %*% My_solve(GH$H, t(G))
return(list(theta.new = new.Theta, G = GH$G, H = GH$H, UHU = UHU))
}
# time = unlist(tr_y[, "time"])
# status = unlist(tr_y[, "status"])
# type = "spline"
# algo = "CD"
# family = 'Cox'
# gamma = 0.95
# kparam=1
# lambda0 = exp(seq(log(2^{-11}), log(2^{2}), length.out = 20))
# lambda_theta = exp(seq(log(2^{-11}), log(2^{2}), length.out = 20))
# wt = rep(1, ncol(x))
cdcosso.cox = function (x, time, status, wt, lambda0, lambda_theta, gamma, type, kparam, scale, algo)
{
n = length(time)
p = length(wt)
# cat("fit COSSO  with n = ", n, "p =", p, "\n")
K = make_anovaKernel(x, x, type = type, kparam, scale)
d = K$numK
# cat("kernel:", type, "and d =", d, "\n")
par(mfrow = c(1,3))
# solve theta
getc_cvfit  = cv.getc(K, time, status, rep(1, d)/wt^2, lambda0, type, kparam, algo, show = TRUE)
theta_cvfit = cv.gettheta(getc_cvfit, x, time, status, wt, getc_cvfit$optlambda, lambda_theta, gamma, type, kparam, algo)
# solve (theta) - 2nd
theta.new = rescale_theta(theta_cvfit$theta.new)
# print(theta.new)
getc_cvfit = cv.getc(K, time, status, theta.new/wt^2, lambda0, type, kparam, algo, show = TRUE)
par(mfrow = c(1,1))
out = list(data = list(x = x, time = time, status = status, RistSet = RiskSet(time, status), R = getc_cvfit$R, kernel = type, kparam = kparam),
tune = list(lambda0 = lambda0, lambda_theta = lambda_theta, gamma = gamma),
c_step = getc_cvfit,
theta_step = theta_cvfit,
family = "Cox",
algorithm = algo)
return(out)
}
x = tr_x
time = unlist(tr_y[, "time"])
status = unlist(tr_y[, "status"])
type = "spline"
algo = "CD"
family = 'Cox'
gamma = 0.95
kparam=1
lambda0 = exp(seq(log(2^{-11}), log(2^{2}), length.out = 20))
lambda_theta = exp(seq(log(2^{-11}), log(2^{2}), length.out = 20))
wt = rep(1, ncol(x))
n = length(time)
p = length(wt)
K = make_anovaKernel(x, x, type = type, kparam, scale)
d = K$numK
par(mfrow = c(1,3))
# solve theta
getc_cvfit  = cv.getc(K, time, status, rep(1, d)/wt^2, lambda0, type, kparam, algo, show = TRUE)
theta_cvfit = cv.gettheta(getc_cvfit, x, time, status, wt, getc_cvfit$optlambda, lambda_theta, gamma, type, kparam, algo)
model = getc_cvfit
lambda0 = getc_cvfit$optlambda
mscale = wt
n = length(time)
d = length(mscale)
IDmat = model$IDmat
RS = RiskSet(time, status)
# solve theta
G <- matrix(0, nrow(model$R[, ,1]), d)
for (j in 1:d) {
G[, j] = model$R[, , j] %*% model$c.new * (mscale[j]^(-2))
}
if(algo == "QP") lambda_theta = exp(seq(log(1e-4), log(40), length.out = length(lambda_theta)))
len = length(lambda_theta)
measure <- rep(0, len)
save_theta <- list()
for (k in 1:len) {
if(algo == "CD"){
init.theta = rep(1, d)
# Gw = G * sqrt(model$w.new)
# uw = model$zw.new - model$b.new * sqrt(model$w.new) - (n/2) * lambda0 * model$cw.new
# theta.new = .Call("theta_step", Gw, uw, n, d, init.theta, lambda_theta[k], gamma)
# save_theta[[k]] <- theta.new
fit = gettheta.cd(init.theta, model$f.new, G, time, status, model$b.new, (n/2) * lambda0 * model$cw.new, lambda_theta[k], gamma, RS)
save_theta[[k]] <- fit$theta.new
theta.adj <- rescale_theta(fit$theta.new)
XX = fit$zw.new - fit$Gw %*% theta.adj
num = t(XX) %*% XX + 1
den = (1 - sum(diag( fit$Gw %*% ginv( t(fit$Gw) %*% fit$Gw) %*% t(fit$Gw) )) / n)^2 + 1
measure[k] <- as.vector(num / den / n)
# measure[k] <- cosso::PartialLik(time, status, RS, G %*% theta.adj)
}
if(algo == "QP"){
init.theta = rep(1, d)
fit = gettheta.QP(init.theta, model$c.new, G, time, status, lambda0, lambda_theta[k], RS)
save_theta[[k]] <- fit$theta.new
theta.adj <- rescale_theta(fit$theta.new)
measure[k] <- cosso::PartialLik(time, status, RS, G %*% theta.adj) + sum(status == 1)/n^2 * (sum(diag(fit$UHU))/(n - 1) - sum(fit$UHU)/(n^2 - n))
# measure[k] = cosso::PartialLik(time, status, RS, G %*% theta.adj) / (1 - sum(fit$theta.new != 0) / n)^2 / n
}
}
measure
k=1
fit = gettheta.cd(init.theta, model$f.new, G, time, status, model$b.new, (n/2) * lambda0 * model$cw.new, lambda_theta[k], gamma, RS)
fit
save_theta[[k]] <- fit$theta.new
theta.adj <- rescale_theta(fit$theta.new)
save_theta
fit$zw.new - fit$Gw %*% theta.adj
fit
