one <- try(optim(par = rep(0.1, 8), logL_H0, lower = c(rep(-Inf, 6), 1e-10, w1), upper = c(rep(Inf, 6), 10, w2),
method = "L-BFGS-B"), silent = TRUE)
if (class(one) == "try-error") {
next
} else {
param <- one$par
param_list[[i]] <- param
}
beta_i <- param[c(1, 3)]
beta_c <- param[c(2, 4)]
gam <- param[(c(5, 6))]
tau <- param[7]
w <- param[8]
d <- 1 - exp(-1)
## Data
y <- sample_data$y;
x <- cbind(sample_data$x1[, 2], sample_data$x2[, 2]);
z <- sample_data$z[,2]
## Parameter
mu <- cbind(exp(sample_data$x1 %*% c(beta_i[1], beta_c[1])), exp(sample_data$x2 %*% c(beta_i[2], beta_c[2])))
## Gradient
gtau_out = tau_gradient(y, x, z, mu, gam, tau, w)
if (class(ginv(gtau_out$I))[[1]] == "try-error") {
next
} else {
}
score <- colSums(gtau_out$G)
score_list[[i]] = score
variance <- ginv(gtau_out$I)[1, 1]  ## J''
result[i] <- score[1]^2 * variance
if (i %% 100 == 0) print(i)
# if(result[i] > 4.4){
#   boot_cric[i, ] <- c(1, 1)
# } else{
#   ###############
#   ## Bootstrap step
#   K = nrow(y)
#   grid = 80
#   score_b <- c()
#
#   for(b in 1:B) {
#     Bsample = Boot_RBZINB(n = param_grid[num, 3], sample_data$x1, sample_data$x2, sample_data$z, beta_i[1], beta_c[1], beta_i[2], beta_c[2], gam[1], gam[2], tau, 0, w)
#
#     w1B = - 1 / max(Bsample$c1 * Bsample$c2, 1 - Bsample$c1 - Bsample$c2 + Bsample$c1 * Bsample$c2)
#     w2B = 1 / max(Bsample$c1 * (1-Bsample$c1), Bsample$c2 * (1-Bsample$c2))
#
#     yB = Bsample$y
#     x1B <- Bsample$x1
#     x2B <- Bsample$x2
#     zB <- Bsample$z
#
#     logLB <- function(paramB) {
#       beta1B <- paramB[c(1, 2)]
#       beta2B <- paramB[c(3, 4)]
#       gammaB <- paramB[c(5, 6)]
#       tauB <- paramB[7]
#       wB <- paramB[8]
#
#       d <- 1 - exp(-1)
#
#       mu1B <- c(exp(x1B %*% beta1B)); mu2B <- c(exp(x2B %*% beta2B))
#       c1B <- (1 + d * mu1B * tauB)^{-1/tauB}
#       c2B <- (1 + d * mu2B * tauB)^{-1/tauB}
#
#       phiB <- c(exp(zB %*% gammaB) / (1 + exp(zB %*% gammaB)))
#       indB <- (yB[, 1] == 0 & yB[, 2] == 0)
#
#       v1 = exp(zB %*% gammaB) + dnbinom(x = 0, mu = mu1B, 1/tauB) * dnbinom(x = 0, mu = mu2B, 1/tauB) * (1 + wB * (1 - c1B) * (1 - c2B))
#       v1 <- ifelse(v1 <= 0, 1e-15, v1)
#       v1 <- sum(log(v1) * indB)
#
#       v21 <- (dnbinom(x = yB[, 1], mu = mu1B, 1/tauB, log = T) + dnbinom(x = yB[, 2], mu = mu2B, 1/tauB, log = T)) * !indB
#       v22 <- c((1 + wB * (exp(-yB[, 1]) - c1B) * (exp(-yB[, 2]) - c2B)) * !indB)
#       v22 <- ifelse(v22 <= 0, log(1e-15), log(v22)) * !indB
#       v2 <- (v21 + v22)*!indB
#       v <- sum(v1) + sum(v2) - sum(log(1+exp(zB %*% gammaB)))
#
#       return(-v)
#     }
#
#     paramB <- try(optim(par = rep(0.1, 8), logLB, lower = c(rep(-Inf, 6), 1e-10, w1B), upper = c(rep(Inf, 6), 10, w2B),
#                         method = "L-BFGS-B"), silent = TRUE)
#
#     if (class(paramB) == "try-error") {
#       next
#     } else {
#
#     }
#
#     beta_iB <- paramB$par[c(1, 3)]
#     beta_cB <- paramB$par[c(2, 4)]
#     gamB <- paramB$par[(c(5, 6))]
#     tauB <- paramB$par[7]
#     wB <- paramB$par[8]
#
#     ## Parameter
#     muB <- cbind(exp(x1B %*% c(beta_iB[1], beta_cB[1])), exp(x2B %*% c(beta_iB[2], beta_cB[2])))
#
#     ## Gradient
#     gtau_outB = tau_gradient(yB, cbind(x1B[, 2], x2B[, 2]), zB[, 2], muB, gamB, tauB, wB)
#     if (class(ginv(gtau_outB$I))[[1]] == "try-error") {
#       next
#     } else {
#
#     }
#     scoreB <- colSums(gtau_outB$G)
#     inv_IB <- ginv(gtau_outB$I)[1,1]  ## J''
#
#     score_b[b] <- scoreB[1] * inv_IB
#
#   }
#
#   # lower <- quantile(score_b, c(.025, .05), na.rm = TRUE)
#   upper <- quantile(score_b, c(.90, .95), na.rm = TRUE)
#   boot_cric[i, 1] <- ifelse((result[i] > upper[1]), 1, 0)
#   boot_cric[i, 2] <- ifelse((result[i] > upper[2]), 1, 0)
#
#   # boot_cric[i, 1] <- ifelse((lower[1] < result[i]) | (result[i] < upper[1]), 1, 0)
#   # boot_cric[i, 2] <- ifelse((lower[2] < result[i]) | (result[i] < upper[2]), 1, 0)
# }
}
# out = list(result = result, boot_cric = boot_cric)
# }
out = list(result = result)
return(out)
}
result_list <- parLapply(cl, X = 1:40, please)
## 결과
n_grid <- c(250, 500)
tau_grid <- c(0.2, 0.4, 0.6, 0.8, 1)
w_grid <- c(-1, 0, 1, 2)
param_grid <- expand.grid(w_grid, tau_grid, n_grid)
qval = c(0.05, 0.1)
upp = qchisq(qval, 1, lower.tail = F)
low = qchisq(qval/2, 1)
mean(result >= upp[1] | result <= low[1])
out = list()
# 스코어 결과
for(ii in 1:40){
cat("\n n =", param_grid[ii, 3], "gam2 =", param_grid[ii, 2], "w =", param_grid[ii, 1], '\n')
b1 = round(mean(result_list[[ii]]$result > upp[1] , na.rm = T), 3)
b2 = round(mean(result_list[[ii]]$result > upp[2] , na.rm = T), 3)
cat(b1, "&", b2, '\n')
# aa = round(colMeans(result_list4[[ii]]$boot_cric, na.rm = T), 3)
# cat(b1, "&", b2, "&", aa[1], "&", aa[2], '\n')
# out[[ii]] = c(param_grid[ii, 3], param_grid[ii, 2], param_grid[ii, 1], round(mean(result_list4[[ii]]$result > upp[2], na.rm = T), 3))
}
please <- function(num) {
library(dplyr)
library(MASS)
RBZINB <- function(n, b10, b11, b20, b21, gam10, gam11, w, tau, eps, grid = 100) {
find_idx <- function(mat) {
if(sum(mat) == 0){
return(c(grid-1, grid-1))
} else{
for (row in 1:grid) {
for (col in 1:grid) {
if (mat[row, col] == TRUE) {
return(c(row - 1, col - 1))
}
}
}
}
}
d <- 1 - exp(-1)
x1 <- cbind(1, runif(n))
x2 <- cbind(1, runif(n))
z <- cbind(1, runif(n))
mu1 <- exp(x1 %*% c(b10, b11));
mu2 <- exp(x2 %*% c(b20, b21));
phi <- exp(z %*% c(gam10, gam11)) / (1 + exp(z %*% c(gam10, gam11)))
tau1 <- tau
tau2 <- tau + eps
c1 <- (1 + d * mu1 * tau1)^{-1/tau1}
c2 <- (1 + d * mu2 * tau2)^{-1/tau2}
y <- matrix(0, nrow = n, ncol = 2)
for (i in 1:n) {
PX <- cbind(dnbinom(0:(grid - 1), mu = mu1[i], size = 1/tau1), dnbinom(0:(grid - 1), mu = mu2[i], size = 1/tau2))
PTMPY <- cbind(exp(-(0:(grid - 1))) - (1 + d * mu1[i] * tau1)^{-1/tau1}, exp(-(0:(grid - 1))) - (1 + d * mu2[i] * tau2)^{-1/tau2})
TXY = matrix(PX[, 1], nrow = grid, ncol = 1) %*% matrix(PX[, 2], nrow = 1, ncol = grid)  *
(1 + w * matrix(PTMPY[, 1], nrow = grid, ncol = 1) %*% matrix(PTMPY[, 2], nrow = 1, ncol = grid))
SXY = matrix(cumsum(TXY %>% t() %>% as.vector()), nrow = grid, ncol = grid, byrow = TRUE)
RAN_N <- runif(1)
if (RAN_N < phi[i]) {
y[i, ] <- c(0, 0)
} else {
RAN_A <- runif(1)
mat = RAN_A < SXY
find_idx(mat)
y[i, ] <- find_idx(mat)
}
}
return(list(y = y, x1 = x1, x2 = x2, z = z, c1 = c1, c2 = c2))
}
Boot_RBZINB <- function(n, x1, x2, z, b10, b11, b20, b21, gam10, gam11, tau, eps, w, grid = 80) {
find_idx <- function(mat) {
if(sum(mat) == 0){
return(c(grid-1, grid-1))
} else{
for (row in 1:grid) {
for (col in 1:grid) {
if (mat[row, col] == TRUE) {
return(c(row - 1, col - 1))
}
}
}
}
}
d <- 1 - exp(-1)
mu1 <- exp(x1 %*% c(b10, b11));
mu2 <- exp(x2 %*% c(b20, b21));
phi <- exp(z %*% c(gam10, gam11)) / (1 + exp(z %*% c(gam10, gam11)))
tau1 <- tau
tau2 <- tau + eps
c1 <- (1 + d * mu1 * tau1)^{-1/tau1}
c2 <- (1 + d * mu2 * tau2)^{-1/tau2}
y <- matrix(0, nrow = n, ncol = 2)
for (i in 1:n) {
PX <- cbind(dnbinom(0:(grid - 1), mu = mu1[i], size = 1/tau1), dnbinom(0:(grid - 1), mu = mu2[i], size = 1/tau2))
PTMPY <- cbind(exp(-(0:(grid - 1))) - (1 + d * mu1[i] * tau1)^{-1/tau1}, exp(-(0:(grid - 1))) - (1 + d * mu2[i] * tau2)^{-1/tau2})
TXY = matrix(PX[, 1], nrow = grid, ncol = 1) %*% matrix(PX[, 2], nrow = 1, ncol = grid)  *
(1 + w * matrix(PTMPY[, 1], nrow = grid, ncol = 1) %*% matrix(PTMPY[, 2], nrow = 1, ncol = grid))
SXY = matrix(cumsum(TXY %>% t() %>% as.vector()), nrow = grid, ncol = grid, byrow = TRUE)
RAN_N <- runif(1)
if (RAN_N < phi[i]) {
y[i, ] <- c(0, 0)
} else {
RAN_A <- runif(1)
mat = RAN_A < SXY
find_idx(mat)
y[i, ] <- find_idx(mat)
}
}
return(list(y = y, x1 = x1, x2 = x2, z = z, c1 = c1, c2 = c2))
}
tau_gradient = function(y, x, z, mu, gam, tau, w){
phi <- exp(cbind(1, z) %*% gam)/(1+exp(cbind(1, z) %*% gam))
psi <- phi / (1 - phi)
c <- cbind((1 + d * mu[, 1] * tau)^{-1/tau}, (1 + d * mu[, 2] * tau)^{-1/tau})
D <- (1 + w * (exp(-y[, 1]) - c[, 1]) * (exp(-y[, 2]) - c[, 2]))
## Indicator
Ind <- (y[, 1] == 0 & y[, 2] == 0)
tm1 <- (1 + mu[, 1] * tau)^{-1/tau}
tm2 <- (1 + mu[, 2] * tau)^{-1/tau}
# gradient
dgam0 <- (exp(cbind(1, z) %*% gam) / (exp(cbind(1, z) %*% gam) + tm1 * tm2 * D)) * Ind -
(exp(cbind(1, z) %*% gam) / (1 + exp(cbind(1, z) %*% gam)))
dgam1 <- (z * exp(cbind(1, z) %*% gam) / (exp(cbind(1, z) %*% gam) + tm1 * tm2 * D)) * Ind -
(z * exp(cbind(1, z) %*% gam) / (1 + exp(cbind(1, z) %*% gam)))
## BETA1
dbeta10 <- (tm1 * tm2 * mu[, 1] * w * d * (1 - c[, 2]) * (1 + d * tau * mu[, 1])^{-1/tau - 1}) / (psi + tm1 * tm2 * D) * Ind -
((tm2 * mu[, 1] * (1 + tau * mu[, 1])^{-1/tau - 1} * D) / (psi + tm1 * tm2 * D)) * Ind +
((y[, 1] - mu[, 1]) / (1 + tau * mu[, 1]) + w * d * mu[, 1] * (exp(-y[, 2]) - c[, 2]) * (1 + d * tau * mu[, 1])^{-1/tau - 1} / D) * !Ind
dbeta11 <- (x[, 1] * tm1 * tm2 * mu[, 1] * w * d * (1 - c[, 2]) * (1 + d * tau * mu[, 1])^{-1/tau - 1}) / (psi + tm1 * tm2 * D) * Ind -
((tm2 * x[, 1] * mu[, 1] * (1 + tau * mu[, 1])^{-1/tau - 1} * D) / (psi + tm1 * tm2 * D)) * Ind +
(x[, 1] * (y[, 1] - mu[, 1]) / (1 + tau * mu[, 1]) + w * d * x[, 1] * mu[, 1] * (exp(-y[, 2]) - c[, 2]) * (1 + d * tau * mu[, 1])^{-1/tau - 1} / D) * !Ind
## BETAA2
dbeta20 <- (tm1 * tm2 * mu[, 2] * w * d * (1 - c[, 1]) * (1 + d * tau * mu[, 2])^{-1/tau - 1}) / (psi + tm1 * tm2 * D) * Ind -
((tm1 * mu[, 2] * (1 + tau * mu[, 2])^{-1/tau - 1} * D) / (psi + tm1 * tm2 * D)) * Ind +
((y[, 2] - mu[, 2]) / (1 + tau * mu[, 2]) + w * d * mu[, 2] * (exp(-y[, 1]) - c[, 1]) * (1 + d * tau * mu[, 2])^{-1/tau - 1} / D) * !Ind
dbeta21 <- (x[, 2] * tm1 * tm2 * mu[, 2] * w * d * (1 - c[, 1]) * (1 + d * tau * mu[, 2])^{-1/tau - 1}) / (psi + tm1 * tm2 * D) * Ind -
((tm1 * x[, 2] * mu[, 2] * (1 + tau * mu[, 2])^{-1/tau - 1} * D) / (psi + tm1 * tm2 * D)) * Ind +
(x[, 2] * (y[, 2] - mu[, 2]) / (1 + tau * mu[, 2]) + w * d * x[, 2] * mu[, 2] * (exp(-y[, 1]) - c[, 1]) * (1 + d * tau * mu[, 2])^{-1/tau - 1} / D) * !Ind
## OMEGA
dw = (tm1 * tm2 * (1 - c[, 1])  * (1 - c[, 2])) / (psi + tm1 * tm2 * D) * Ind +
((exp(-y[, 1]) - c[, 1]) * (exp(-y[, 2]) - c[, 2]) / D) * !Ind
## TAU
a1 = sapply(1:nrow(y), function(i){
sv = 0
if(y[i, 1] > 0){
for(v in 1:y[i, 1]){
sv = sv + (y[i,1] - v) / (1 + tau * y[i, 1] - tau * v)
}
}
return (sv)
})
a2 = sapply(1:nrow(y), function(i){
sv = 0
if(y[i, 2] > 0){
for(v in 1:y[i, 2]){
sv = sv + (y[i,2] - v) / (1 + tau * y[i, 2] - tau * v)
}
}
return (sv)
})
dtau1_a = ((tm1 * tm2 * D * (tau^{-2} * log(1 + tau * mu[,1]) - mu[, 1] * tau^{-1} / (1 + tau * mu[, 1]))) / (exp(cbind(1, z) %*% gam) + tm1 * tm2 * D)) * Ind
dtau1_b = ((w * (1 - c[, 2]) * tm1 * tm2 * c[, 1] * (tau^{-2} * log(1 + d * tau * mu[,1]) - d * mu[, 1] * tau^{-1} / (1 + d * tau * mu[, 1])))  / (exp(cbind(1, z) %*% gam) + tm1 * tm2 * D)) * Ind
dtau1_c = (a1 - (mu[, 1] * y[, 1]) / (1 + tau * mu[, 1]) + (tau^{-2} * log(1 + tau * mu[,1]) - mu[, 1] * tau^{-1} / (1 + tau * mu[, 1])) ) * !Ind
dtau1_d = (w * (exp(-y[, 2]) - c[, 2]) * c[, 1] * (tau^{-2} * log(1 + d * tau * mu[,1]) - d * mu[, 1] * tau^{-1} / (1 + d * tau * mu[, 1]) ) / D) * !Ind
dtau1 = dtau1_a - dtau1_b + dtau1_c - dtau1_d
colSums(dtau1)
dtau2_a = ((tm1 * tm2 * D * (tau^{-2} * log(1 + tau * mu[,2]) - mu[, 2] * tau^{-1} / (1 + tau * mu[, 2]))) / (exp(cbind(1, z) %*% gam) + tm1 * tm2 * D)) * Ind
dtau2_b = ((w * (1 - c[, 1]) * tm1 * tm2 * c[, 2] * (tau^{-2} * log(1 + d * tau * mu[,2]) - d * mu[, 2] * tau^{-1} / (1 + d * tau * mu[, 2])))  / (exp(cbind(1, z) %*% gam) + tm1 * tm2 * D)) * Ind
dtau2_c = (a2 - (mu[, 2] * y[, 2]) / (1 + tau * mu[, 2]) - (tau * mu[, 2] / (1 + tau * mu[, 2]) - log(1 + tau * mu[,2])) / tau^{2} ) * !Ind
dtau2_d = (w * (exp(-y[, 1]) - c[, 1]) * c[, 2] * (tau^{-2} * log(1 + d * tau * mu[,2]) - d * tau^{-1} * mu[, 2] / (1 + d * tau * mu[, 2]) ) / D) * !Ind
dtau2 = dtau2_a - dtau2_b + dtau2_c - dtau2_d
colSums(dtau2)
dtau = dtau1 + dtau2
deps <- dtau2
gr_df <- data.frame(deps, dtau, dgam0, dgam1, dbeta10, dbeta11, dbeta20, dbeta21, dw)
I <- matrix(c(colSums(gr_df * deps),
colSums(gr_df * dtau),
colSums(gr_df * dgam0),
colSums(gr_df * dgam1),
colSums(gr_df * dbeta10),
colSums(gr_df * dbeta11),
colSums(gr_df * dbeta20),
colSums(gr_df * dbeta21),
colSums(gr_df * dw)), 9, 9)
return(list(G = gr_df, I = I))
}
logL_H0 <- function(param) {
beta1 <- param[c(1, 2)]
beta2 <- param[c(3, 4)]
gamma <- param[c(5, 6)]
tau <- param[7]
w <- param[8]
d <- 1 - exp(-1)
y <- sample_data$y; x1 <- sample_data$x1; x2 <- sample_data$x2; z <- sample_data$z
mu1 <- c(exp(x1 %*% beta1)); mu2 <- c(exp(x2 %*% beta2))
c1 <- (1 + d * mu1 * tau)^{-1/tau}; c2 <- (1 + d * mu2 * tau)^{-1/tau}
phi <- c(exp(z %*% gamma) / (1 + exp(z %*% gamma)))
zg <- c(exp(z %*% gamma))
ind <- (y[, 1] == 0 & y[, 2] == 0)
v1 <- sum(log(exp(z %*% gamma) + dnbinom(0, mu = mu1, size = 1/tau) * dnbinom(0, mu = mu2, size = 1/tau) * (1 + w * (1 - c1) * (1 - c2))) * ind)
v21 <- (dnbinom(x = y[, 1], mu = mu1, size = 1/tau, log = T) + dnbinom(x = y[, 2], mu = mu2, size = 1/tau, log = T)) * !ind
v22 <- c((1 + w * (exp(-y[, 1]) - c1) * (exp(-y[, 2]) - c2)) * !ind)
v22 <- ifelse(v22 <= 0, log(1e-15), log(v22)) * !ind
v2 <- (v21 + v22)*!ind
logbp <- sum(v1) + sum(v2) - sum(log(1+exp(z %*% gamma)))
return(-logbp)
}
## Iteration #################################################################
# i = 1
iteration = 100000
B = 1000
result <- c()
boot_cric <- B_score <- matrix(NA, B, 2)
# n_grid <- c(200, 500)
n_grid <- c(250, 500)
tau_grid <- c(0.2, 0.4, 0.6, 0.8, 1)
w_grid <- c(-1, 0, 1, 2)
param_list = list()
score_list = list()
param_grid <- expand.grid(w_grid, tau_grid, n_grid)
out = list()
# for(num in 1:40){
for(i in 1:iteration) {
set.seed(i)
print(i)
sample_data <- RBZINB(n = param_grid[num, 3], .2, .4, .4, .8, -1.2, 2.4, param_grid[num, 1], param_grid[num, 2], 0)
w1 = - 1 / max(sample_data$c1 * sample_data$c2, 1 - sample_data$c1 - sample_data$c2 + sample_data$c1 * sample_data$c2)
w2 = 1 / max(sample_data$c1 * (1-sample_data$c1), sample_data$c2 * (1-sample_data$c2))
one <- try(optim(par = rep(0.1, 8), logL_H0, lower = c(rep(-Inf, 6), 1e-10, -Inf), upper = c(rep(Inf, 8)),
method = "L-BFGS-B"), silent = TRUE)
if (class(one) == "try-error") {
next
} else {
param <- one$par
param_list[[i]] <- param
}
beta_i <- param[c(1, 3)]
beta_c <- param[c(2, 4)]
gam <- param[(c(5, 6))]
tau <- param[7]
w <- param[8]
d <- 1 - exp(-1)
## Data
y <- sample_data$y;
x <- cbind(sample_data$x1[, 2], sample_data$x2[, 2]);
z <- sample_data$z[,2]
## Parameter
mu <- cbind(exp(sample_data$x1 %*% c(beta_i[1], beta_c[1])), exp(sample_data$x2 %*% c(beta_i[2], beta_c[2])))
## Gradient
gtau_out = tau_gradient(y, x, z, mu, gam, tau, w)
if (class(ginv(gtau_out$I))[[1]] == "try-error") {
next
} else {
}
score <- colSums(gtau_out$G)
score_list[[i]] = score
variance <- ginv(gtau_out$I)[1, 1]  ## J''
result[i] <- score[1]^2 * variance
if (i %% 100 == 0) print(i)
# if(result[i] > 4.4){
#   boot_cric[i, ] <- c(1, 1)
# } else{
#   ###############
#   ## Bootstrap step
#   K = nrow(y)
#   grid = 80
#   score_b <- c()
#
#   for(b in 1:B) {
#     Bsample = Boot_RBZINB(n = param_grid[num, 3], sample_data$x1, sample_data$x2, sample_data$z, beta_i[1], beta_c[1], beta_i[2], beta_c[2], gam[1], gam[2], tau, 0, w)
#
#     w1B = - 1 / max(Bsample$c1 * Bsample$c2, 1 - Bsample$c1 - Bsample$c2 + Bsample$c1 * Bsample$c2)
#     w2B = 1 / max(Bsample$c1 * (1-Bsample$c1), Bsample$c2 * (1-Bsample$c2))
#
#     yB = Bsample$y
#     x1B <- Bsample$x1
#     x2B <- Bsample$x2
#     zB <- Bsample$z
#
#     logLB <- function(paramB) {
#       beta1B <- paramB[c(1, 2)]
#       beta2B <- paramB[c(3, 4)]
#       gammaB <- paramB[c(5, 6)]
#       tauB <- paramB[7]
#       wB <- paramB[8]
#
#       d <- 1 - exp(-1)
#
#       mu1B <- c(exp(x1B %*% beta1B)); mu2B <- c(exp(x2B %*% beta2B))
#       c1B <- (1 + d * mu1B * tauB)^{-1/tauB}
#       c2B <- (1 + d * mu2B * tauB)^{-1/tauB}
#
#       phiB <- c(exp(zB %*% gammaB) / (1 + exp(zB %*% gammaB)))
#       indB <- (yB[, 1] == 0 & yB[, 2] == 0)
#
#       v1 = exp(zB %*% gammaB) + dnbinom(x = 0, mu = mu1B, 1/tauB) * dnbinom(x = 0, mu = mu2B, 1/tauB) * (1 + wB * (1 - c1B) * (1 - c2B))
#       v1 <- ifelse(v1 <= 0, 1e-15, v1)
#       v1 <- sum(log(v1) * indB)
#
#       v21 <- (dnbinom(x = yB[, 1], mu = mu1B, 1/tauB, log = T) + dnbinom(x = yB[, 2], mu = mu2B, 1/tauB, log = T)) * !indB
#       v22 <- c((1 + wB * (exp(-yB[, 1]) - c1B) * (exp(-yB[, 2]) - c2B)) * !indB)
#       v22 <- ifelse(v22 <= 0, log(1e-15), log(v22)) * !indB
#       v2 <- (v21 + v22)*!indB
#       v <- sum(v1) + sum(v2) - sum(log(1+exp(zB %*% gammaB)))
#
#       return(-v)
#     }
#
#     paramB <- try(optim(par = rep(0.1, 8), logLB, lower = c(rep(-Inf, 6), 1e-10, w1B), upper = c(rep(Inf, 6), 10, w2B),
#                         method = "L-BFGS-B"), silent = TRUE)
#
#     if (class(paramB) == "try-error") {
#       next
#     } else {
#
#     }
#
#     beta_iB <- paramB$par[c(1, 3)]
#     beta_cB <- paramB$par[c(2, 4)]
#     gamB <- paramB$par[(c(5, 6))]
#     tauB <- paramB$par[7]
#     wB <- paramB$par[8]
#
#     ## Parameter
#     muB <- cbind(exp(x1B %*% c(beta_iB[1], beta_cB[1])), exp(x2B %*% c(beta_iB[2], beta_cB[2])))
#
#     ## Gradient
#     gtau_outB = tau_gradient(yB, cbind(x1B[, 2], x2B[, 2]), zB[, 2], muB, gamB, tauB, wB)
#     if (class(ginv(gtau_outB$I))[[1]] == "try-error") {
#       next
#     } else {
#
#     }
#     scoreB <- colSums(gtau_outB$G)
#     inv_IB <- ginv(gtau_outB$I)[1,1]  ## J''
#
#     score_b[b] <- scoreB[1] * inv_IB
#
#   }
#
#   # lower <- quantile(score_b, c(.025, .05), na.rm = TRUE)
#   upper <- quantile(score_b, c(.90, .95), na.rm = TRUE)
#   boot_cric[i, 1] <- ifelse((result[i] > upper[1]), 1, 0)
#   boot_cric[i, 2] <- ifelse((result[i] > upper[2]), 1, 0)
#
#   # boot_cric[i, 1] <- ifelse((lower[1] < result[i]) | (result[i] < upper[1]), 1, 0)
#   # boot_cric[i, 2] <- ifelse((lower[2] < result[i]) | (result[i] < upper[2]), 1, 0)
# }
}
# out = list(result = result, boot_cric = boot_cric)
# }
out = list(result = result)
return(out)
}
result_list <- parLapply(cl, X = 1:40, please)
## 결과
n_grid <- c(250, 500)
tau_grid <- c(0.2, 0.4, 0.6, 0.8, 1)
w_grid <- c(-1, 0, 1, 2)
param_grid <- expand.grid(w_grid, tau_grid, n_grid)
qval = c(0.05, 0.1)
upp = qchisq(qval, 1, lower.tail = F)
out = list()
# 스코어 결과
for(ii in 1:40){
cat("\n n =", param_grid[ii, 3], "gam2 =", param_grid[ii, 2], "w =", param_grid[ii, 1], '\n')
b1 = round(mean(result_list[[ii]]$result > upp[1] , na.rm = T), 3)
b2 = round(mean(result_list[[ii]]$result > upp[2] , na.rm = T), 3)
cat(b1, "&", b2, '\n')
# aa = round(colMeans(result_list4[[ii]]$boot_cric, na.rm = T), 3)
# cat(b1, "&", b2, "&", aa[1], "&", aa[2], '\n')
# out[[ii]] = c(param_grid[ii, 3], param_grid[ii, 2], param_grid[ii, 1], round(mean(result_list4[[ii]]$result > upp[2], na.rm = T), 3))
}
1/1.74
2.08+0.80+3.30+9.45
15.56/1.74
1.74^2
15.56/3.0276]
15.56/3.0276
sqrt(15.63)
3.953479/1.74
15.63/3.0276
15.63/1.74
(15.63+1.74)/1.74
sqrt(2/(p-5))
sqrt(2/(c(25, 50, 100)-5))
sqrt(1.5/(c(25, 50, 100)-5))
