#' Load a matrix from a file
#'
#' The predict.cdcosso function is a function that receives the object and test data (testx) of the cdcosso package as input
#' and generates a predicted value for the test data.
#' This function uses the given test data to calculate predictions from the weights and biases generated by the model.
#'
#' @param n Model object fitted from the cdcosso package.
#' @param p The test data you want to predict.
#' @param rho The test data you want to predict.
#' @param a The test data you want to predict.
#' @param type The test data you want to predict.
#' @param response The test data you want to predict.
#'
#' @return a list containing the predicted value for the test data (f.new) and the transformed value of that predicted value (mu.new).
#' @export
data_generation = function(n, p, rho, a,
                           type = c("indep", "linear", "additive", "interaction", "survival"),
                           response = c("regression", "classification", "count")){
  f1 = function(t) t - 0.5
  f2 = function(t) 2 * (cos(2 * pi * t) + sin(pi * t)) - 1.4
  f3 = function(t) (cos(2 * t) + sin(6 * t)) - 0.5
  f4 = function(t) t^17 * (8*(1-t))^6 + 10 * (8 * t)^3 * (1-t)^15 - 0.7
  f5 = function(t) (sin(6 * t)^{3} + cos(6 * t)^{9})

  # f1 = function(t) t - 0.5
  # f2 = function(t) 2 * (cos(2 * pi * t) + sin(pi * t)) - 1.2
  # f3 = function(t) sin(6 * t)
  # f4 = function(t) t^17 * (8*(1-t))^6 + 10 * (8 * t)^3 * (1-t)^15 - 0.7
  # f5 = function(t) -(sin(3 * t)^{2} + cos(3 * t)^{3}) + 0.7

  if(missing(type))
    type = "indep"
  type = match.arg(type)

  if(missing(n)) n = 200
  if(missing(p)) p = 10
  if(missing(rho)) rho = 0.5

  if(type != 'survival'){

    if(missing(response))
      response = "regression"
    response = match.arg(response)

    if(type == 'indep'){
      Sigma = matrix(rho, 5, 5)
      diag(Sigma) = 1

      beta = c(rep(3, 5), rep(0, p-5))
      x_sig = pnorm(rmvnorm(n, mean = rep(0, 5), sigma = Sigma))
      x_nois = pnorm(matrix(rnorm(n * (p-5)), n, p-5))
      x = cbind(x_sig, x_nois)
      pi = exp(x %*% beta) / (exp(x %*% beta) + 1)
      f = rbinom(n, 1, pi)
    }

    if(type == 'linear'){
      Sigma = matrix(rho, 5, 5)
      diag(Sigma) = 1

      beta = c(rep(2, 5), rep(0, p-5))
      x_sig = rmvnorm(n, mean = rep(0, 5), sigma = Sigma)
      x_nois = matrix(rnorm(n * (p-5)), n, p-5)
      x = cbind(x_sig, x_nois)
      f = x %*% beta
    }

    if(type == "additive"){
      if(p <= 5) stop("dimension size should be larger than 6.")

      Sigma = matrix(rho, 5, 5)
      diag(Sigma) = 1

      x_sig = pnorm(rmvnorm(n, sigma = Sigma))
      x_nois = pnorm(matrix(rnorm(n * (p-5)), n, p-5))
      x = cbind(x_sig, x_nois)

      # Set the outer margins
      # par(oma = c(0, 0, 0, 0))
      # Set the inner margin
      # par(mar = c(4, 4, 3, 1))
      # par(mfrow = c(1,5))
      # plot(x[,1], f1(x[,1]), cex = .6, pch = 16, xlab = 'x1', ylab = 'f1')
      # plot(x[,2], f2(x[,2]), cex = .6, pch = 16, xlab = 'x2', ylab = 'f2')
      # plot(x[,3], f3(x[,3]), cex = .6, pch = 16, xlab = 'x3', ylab = 'f3')
      # plot(x[,4], f4(x[,4]), cex = .6, pch = 16, xlab = 'x4', ylab = 'f4')
      # plot(x[,5], f5(x[,5]), cex = .6, pch = 16, xlab = 'x5', ylab = 'f5')
      # par(mfrow = c(1,1))

      f = 2 * f1(x[,1]) + 3 * f2(x[,2]) + 4 * f3(x[,3]) + 1 * f4(x[,4]) + 2 * f5(x[,5])

    }

    if(type == 'interaction'){

      if(p <= 5) stop("dimension size should be larger than 6.")

      x = matrix(runif(n*p), n, p)

      Sigma = matrix(rho, 5, 5)
      diag(Sigma) = 1

      x_sig = rmvnorm(n, mean = rep(0, 5), sigma = Sigma)
      x_nois = matrix(rnorm(n * (p-5)), n, p-5)
      x = cbind(x_sig, x_nois) + rnorm(n, 0, 0.01)

      f = 3*f1(x[,1])*f2(x[,2]) + 2*f3(x[,3])*f4(x[,4]) + 3*f4(x[,4])*f5(x[,5]) + 2*f1(x[,1])*f4(x[,4]) + 3*f2(x[,2])*f3(x[,3])

      prob = exp(f)/(exp(f) + 1)
      y = rbinom(n, 1, prob)
      # plot(prob)
      # table(y)
    }

    if(response == "regression"){
      out = list(x = x, y = f)
    }

    if(response == "classification"){
      prob = exp(f)/(exp(f) + 1)
      y = rbinom(n, 1, prob)
      # plot(prob)
      # print(table(y))
      out = list(x = x, f = f, y = y)
    }

    if(response == "count"){
      mu = exp(f)
      mu = ifelse(mu > 200, 200, mu)
      y = rpois(n, mu)
      out = list(x = x, f = f, y = y)
    }
    return(out)

  }else if(type == 'survival'){

    if(p <= 5) stop("dimension size should be larger than 6.")
    if(missing(a)) a = 0.3

    x = matrix(runif(n*p), n, p)

    Sigma = matrix(rho, 5, 5)
    diag(Sigma) = 1

    x_sig = rmvnorm(n, mean = rep(0, 5), sigma = Sigma)
    x_nois = matrix(rnorm(n * (p-5)), n, p-5)
    x = cbind(x_sig, x_nois)

    f = (f1(x[,1]) + f2(x[,2]) + f3(x[,3]) + f4(x[,4]) + f5(x[,5]))

    surTime = rexp(n, exp(f))
    cenTime = rexp(n, exp(-f) * runif(1, 4, 5))
    y = cbind(time = apply(cbind(surTime, cenTime), 1, min), status = 1 * (surTime < cenTime))

    return(list(x = x, f = f, y = y))
  }

}

# tt = data_generation(200, p, type = "additive", response = "classification")
# range(exp(tt$f))
